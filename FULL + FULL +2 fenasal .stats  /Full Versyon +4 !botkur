import wwjs from "whatsapp-web.js";
const { Client, LocalAuth } = wwjs;
import qrcode from "qrcode-terminal";
import fs from "fs";
import path from "path";
import dotenv from "dotenv";
import { Low } from "lowdb";
import { JSONFile } from "lowdb/node";

dotenv.config();

/* ==================== Telefon YardÄ±mcÄ±larÄ± ==================== */
function normPhone(raw) {
  const d = (raw || "").replace(/\D/g, "");
  if (d.startsWith("90") && d.length === 12) return d;       // 90xxxxxxxxxx
  if (d.startsWith("0") && d.length === 11) return "9" + d;  // 0xxxxxxxxxx -> 90xxxxxxxxxx
  if (d.length === 10) return "90" + d;                      // xxxxxxxxxx  -> 90xxxxxxxxxx
  return d;
}
function last10(s) {
  const d = (s || "").replace(/\D/g, "");
  return d.slice(-10);
}
/* ==================== DB Kurulumu ==================== */
const DATA_DIR = process.env.DATA_DIR || "./data";
if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });

const dbFile = path.join(DATA_DIR, "players.json");
const adapter = new JSONFile(dbFile);

// ğŸ”¹ ArtÄ±k grup ayarlarÄ± da DB'de tutuluyor
const db = new Low(adapter, { players: {}, groupSettings: {} });

await (async () => {
  try { await db.read(); }
  catch {
    db.data = { players: {}, groupSettings: {} };
    await db.write();
  }
})();
if (!db.data) db.data = { players: {}, groupSettings: {} };
if (!db.data.groupSettings) db.data.groupSettings = {};

const STARTING_STACK = parseInt(process.env.STARTING_STACK || "100", 10);
const MIN_BET = parseInt(process.env.MIN_BET || "5", 10);
const DAILY_REWARD = parseInt(process.env.DAILY_REWARD || "2500", 10); // GÃœNLÃœK Ã–DÃœL 2500
const AUTO_TOPUP = parseInt(process.env.AUTO_TOPUP || "3000", 10);

/* ==== Admin yapÄ±landÄ±rma (.env + kalÄ±cÄ± dosya) ==== */
const ADMIN_PIN = (process.env.ADMIN_PIN || "1234").trim();
const ADMIN_PHONES = (process.env.ADMIN_PHONES || process.env.ADMIN_PHONE || "")
  .split(",")
  .map(s => s.trim())
  .filter(Boolean)
  .map(normPhone);

// KalÄ±cÄ± admin dosyasÄ±
const adminsFile = path.join(DATA_DIR, "admins.json");
if (!fs.existsSync(adminsFile)) {
  fs.writeFileSync(adminsFile, JSON.stringify({ phones: [], lids: [] }, null, 2), "utf8");
}
function readAdmins() {
  try { return JSON.parse(fs.readFileSync(adminsFile, "utf8")); }
  catch { return { phones: [], lids: [] }; }
}
function writeAdmins(obj) {
  fs.writeFileSync(adminsFile, JSON.stringify(obj, null, 2), "utf8");
}

/* ==================== Utils ==================== */
function localDateKey(ms = Date.now(), tz = "Europe/Istanbul") {
  return new Date(ms).toLocaleDateString("tr-TR", { timeZone: tz });
}
async function saveDB() { await db.write(); }

function randInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function normalizeTR(s) {
  return (s || "")
    .toLowerCase()
    .replace(/Ä±/g, "i")
    .replace(/ÅŸ/g, "s")
    .replace(/Ã§/g, "c")
    .replace(/Ã¶/g, "o")
    .replace(/Ã¼/g, "u")
    .replace(/ÄŸ/g, "g")
    .trim();
}

/* ===== Global Event Buff (admin etkinliÄŸi) ===== */
let eventBuff = {
  active: false,
  until: 0
};

function isEventBuffActive() {
  if (!eventBuff.active) return false;
  if (Date.now() >= eventBuff.until) {
    eventBuff.active = false;
    eventBuff.until = 0;
    return false;
  }
  return true;
}

function eventBuffRemainingText() {
  if (!isEventBuffActive()) return "kapalÄ±";
  const ms = eventBuff.until - Date.now();
  const sec = Math.max(1, Math.round(ms / 1000));
  const min = Math.floor(sec / 60);
  const s = sec % 60;
  return min > 0 ? `${min} dk ${s} sn` : `${s} sn`;
}

/* ===== Ä°STATÄ°STÄ°K, ENVANTER, GÃ–REV, PET VE UNVAN SÄ°STEMÄ° ===== */

/* --- Oyuncu istatistikleri --- */
function ensureStats(player) {
  if (!player.stats || typeof player.stats !== "object") {
    player.stats = {
      slotGames: 0,
      slotNetWin: 0,
      rouletteGames: 0,
      rouletteWins: 0,
      rouletteLosses: 0,
      bjGames: 0,
      bjWins: 0,
      bjLosses: 0,
      dailyDays: 0,
      huntCount: 0,
      huntProfit: 0,
      boxesOpened: 0
    };
  } else {
    const s = player.stats;
    if (typeof s.slotGames !== "number") s.slotGames = 0;
    if (typeof s.slotNetWin !== "number") s.slotNetWin = 0;
    if (typeof s.rouletteGames !== "number") s.rouletteGames = 0;
    if (typeof s.rouletteWins !== "number") s.rouletteWins = 0;
    if (typeof s.rouletteLosses !== "number") s.rouletteLosses = 0;
    if (typeof s.bjGames !== "number") s.bjGames = 0;
    if (typeof s.bjWins !== "number") s.bjWins = 0;
    if (typeof s.bjLosses !== "number") s.bjLosses = 0;
    if (typeof s.dailyDays !== "number") s.dailyDays = 0;
    if (typeof s.huntCount !== "number") s.huntCount = 0;
    if (typeof s.huntProfit !== "number") s.huntProfit = 0;
    if (typeof s.boxesOpened !== "number") s.boxesOpened = 0;
  }
}

/* --- Seviye sistemi: istatistiklerden hesaplanÄ±r --- */
function calculatePlayerLevel(player) {
  ensureStats(player);
  const s = player.stats || {};

  const totalXp =
    (s.slotGames || 0)     * 2 +
    (s.rouletteGames || 0) * 3 +
    (s.bjGames || 0)       * 3 +
    (s.huntCount || 0)     * 5 +
    (s.boxesOpened || 0)   * 4 +
    (s.dailyDays || 0)     * 10;

  const level = Math.max(1, Math.floor(totalXp / 100) + 1);

  return { level, totalXp };
}

/* --- Envanter (kutu) --- */
function ensureInventory(player) {
  if (!player.inv || typeof player.inv !== "object") {
    player.inv = { boxes: 0 };
  } else {
    if (typeof player.inv.boxes !== "number") player.inv.boxes = 0;
  }
}
/* --- Pet sistemi: Ã§oklu pet + aktif pet + pasif katkÄ± --- */
const PET_SHOP = {
  cekirge: {
    key: "cekirge",
    emoji: "ğŸ¦—",
    label: "Ã‡ekirge",
    price: 6000,
    atk: 5,
    luck: 15,
    buyable: true,
    desc: "HÄ±zlÄ± ve ÅŸanslÄ±, ucuz giriÅŸ seviyesi pet."
  },
  karinca: {
    key: "karinca",
    emoji: "ğŸœ",
    label: "KarÄ±nca",
    price: 8000,
    atk: 8,
    luck: 8,
    buyable: true,
    desc: "KÃ¼Ã§Ã¼k ama Ã§alÄ±ÅŸkan; uzun vadede saÄŸlam katkÄ±."
  },
  panda: {
    key: "panda",
    emoji: "ğŸ¼",
    label: "Panda",
    price: 16000,
    atk: 30,
    luck: 30,
    buyable: true,
    desc: "Dengeli ve gÃ¼Ã§lÃ¼ bir pet."
  },
  keci: {
    key: "keci",
    emoji: "ğŸ",
    label: "KeÃ§i",
    price: 24000,
    atk: 40,
    luck: 20,
    buyable: true,
    desc: "Ä°natÃ§Ä±; Ã¶zellikle hunt kazancÄ±nÄ± bufflar."
  },
  at: {
    key: "at",
    emoji: "ğŸ´",
    label: "At",
    price: 30000,
    atk: 35,
    luck: 15,
    buyable: true,
    desc: "Dengeli, hÄ±z odaklÄ± pet."
  },
  zebra: {
    key: "zebra",
    emoji: "ğŸ¦“",
    label: "Zebra",
    price: 36000,
    atk: 30,
    luck: 25,
    buyable: true,
    desc: "Hem ÅŸans hem saldÄ±rÄ± aÃ§Ä±sÄ±ndan ortalama Ã¼stÃ¼."
  },
  kedi: {
    key: "kedi",
    emoji: "ğŸ±",
    label: "Kedi",
    price: 40000,
    atk: 10,
    luck: 20,
    buyable: true,
    desc: "Dengeli, ÅŸanslÄ± kÃ¼Ã§Ã¼k bir avcÄ±."
  },
  tavsan: {
    key: "tavsan",
    emoji: "ğŸ°",
    label: "TavÅŸan",
    price: 44000,
    atk: 10,
    luck: 30,
    buyable: true,
    desc: "Ã‡ok ÅŸanslÄ±, Ã¶zellikle kutu ve drop iÅŸinde iyi."
  },
  kopek: {
    key: "kopek",
    emoji: "ğŸ¶",
    label: "KÃ¶pek",
    price: 50000,
    atk: 20,
    luck: 10,
    buyable: true,
    desc: "Daha agresif; hunt kazancÄ± biraz daha yÃ¼ksek."
  },
  kartal: {
    key: "kartal",
    emoji: "ğŸ¦…",
    label: "Kartal",
    price: 60000,
    atk: 45,
    luck: 35,
    buyable: true,
    desc: "YÃ¼ksek gÃ¶rÃ¼ÅŸ, yÃ¼ksek ÅŸans."
  },
  suaygiri: {
    key: "suaygiri",
    emoji: "ğŸ¦›",
    label: "Su AygÄ±rÄ±",
    price: 64000,
    atk: 60,
    luck: 25,
    buyable: true,
    desc: "AÄŸÄ±r ve tank; hunt kazancÄ±nÄ± iyi bufflar."
  },
  fil: {
    key: "fil",
    emoji: "ğŸ˜",
    label: "Fil",
    price: 80000,
    atk: 70,
    luck: 30,
    buyable: true,
    desc: "GÃ¼Ã§lÃ¼, sabit ve gÃ¼venilir pet."
  },
  tilki: {
    key: "tilki",
    emoji: "ğŸ¦Š",
    label: "Tilki",
    price: 90000,
    atk: 30,
    luck: 20,
    buyable: true,
    desc: "Kurnaz avcÄ±; hem hunt hem kutuda gÃ¼Ã§lÃ¼."
  },
  gergedan: {
    key: "gergedan",
    emoji: "ğŸ¦",
    label: "Gergedan",
    price: 120000,
    atk: 90,
    luck: 20,
    buyable: true,
    desc: "AÄŸÄ±r darbe vuran, saldÄ±rÄ± odaklÄ± pet."
  },
  cita: {
    key: "cita",
    emoji: "ğŸ†",
    label: "Ã‡ita",
    price: 150000,
    atk: 100,
    luck: 35,
    buyable: true,
    desc: "Ã‡ok hÄ±zlÄ± ve tehlikeli avcÄ±."
  },
  aslan: {
    key: "aslan",
    emoji: "ğŸ¦",
    label: "Aslan",
    price: 200000,
    atk: 150,
    luck: 40,
    buyable: true,
    desc: "OrmanÄ±n kralÄ±; efsane gÃ¼Ã§te pet."
  },
  ejderha: {
    key: "ejderha",
    emoji: "ğŸ‰",
    label: "Ejderha",
    price: 400000,
    atk: 100,
    luck: 100,
    buyable: true,
    desc: "Efsane pet. Hem yÃ¼ksek kazanÃ§ hem ekstra ÅŸans."
  },

  /* â€” Kutudan Ã§Ä±kan Ã¶zel petler (satÄ±n alÄ±namaz) â€” */
  kaplumbaga: {
    key: "kaplumbaga",
    emoji: "ğŸ¢",
    label: "KaplumbaÄŸa (Koleksiyon)",
    price: 0,
    atk: 50,
    luck: 50,
    buyable: false,
    desc: "Sadece kutudan Ã§Ä±kan koleksiyon peti."
  },
  salyangoz: {
    key: "salyangoz",
    emoji: "ğŸŒ",
    label: "Salyangoz (Ã–zel)",
    price: 0,
    atk: 20,
    luck: 10,
    buyable: false,
    desc: "Sadece kutudan Ã§Ä±kan Ã¶zel pet. Hunt drop ÅŸansÄ±nÄ± arttÄ±rÄ±r."
  },
  koala: {
    key: "koala",
    emoji: "ğŸ¨",
    label: "Koala (Efsane)",
    price: 0,
    atk: 30,
    luck: 30,
    buyable: false,
    desc: "Sadece kutudan Ã§Ä±kan efsane pet. Bot aÃ§Ä±kken her 30 dakikada bir +3000 Ã§ip pasif gelir kazandÄ±rÄ±r."
  }
};

/* --- Adminâ€™e Ã¶zel pet --- */
const ADMIN_PET = {
  key: "adminkurt",
  emoji: "ğŸº",
  label: "Alfa Kurt",
  atk: 999,
  luck: 999
};

function petTypeFromInput(raw) {
  const t = normalizeTR(raw || "");
  if (["cekirge","cekirga","cikrik"].includes(t)) return "cekirge";
  if (["karinca","karÄ±nca","ant"].includes(t)) return "karinca";
  if (["panda"].includes(t)) return "panda";
  if (["keci","keÃ§i","goat"].includes(t)) return "keci";
  if (["at","horse"].includes(t)) return "at";
  if (["zebra"].includes(t)) return "zebra";
  if (["kedi","cat","pisi"].includes(t)) return "kedi";
  if (["tavsan","tavÅŸan","rabbit","bunny"].includes(t)) return "tavsan";
  if (["kopek","kÃ¶pek","kope","dog"].includes(t)) return "kopek";
  if (["kartal","eagle"].includes(t)) return "kartal";
  if (["suaygiri","su","aygiri","hippo"].includes(t)) return "suaygiri";
  if (["fil","elephant"].includes(t)) return "fil";
  if (["tilki","fox"].includes(t)) return "tilki";
  if (["gergedan","rhino"].includes(t)) return "gergedan";
  if (["cita","Ã§ita","cheetah"].includes(t)) return "cita";
  if (["aslan","lion"].includes(t)) return "aslan";
  if (["ejder","ejderha","dragon"].includes(t)) return "ejderha";
  return null;
}

function ensurePet(player) {
  if (!player.pets) {
    if (player.pet) {
      player.pets = [player.pet];
    } else {
      player.pets = [];
    }
  }
  if (!Array.isArray(player.pets)) player.pets = [];
  if (typeof player.activePetIndex !== "number") {
    player.activePetIndex = player.pets.length ? 0 : -1;
  }
  if (player.activePetIndex >= player.pets.length) {
    player.activePetIndex = player.pets.length ? 0 : -1;
  }
  player.pet = player.pets[player.activePetIndex] || null;
}

function getPetDisplayName(p) {
  if (!p) return "-";
  const def = p.type && PET_SHOP[p.type];
  const base = def?.label || p.type || "Pet";
  if (p.name && p.name !== base) return `${p.name} (${base})`;
  return base;
}

function getPetPower(player) {
  ensurePet(player);
  const pets = player.pets || [];
  if (!pets.length) {
    return { atk: 0, luck: 0, active: null, others: [] };
  }
  let idx = player.activePetIndex;
  if (!Number.isFinite(idx) || idx < 0 || idx >= pets.length) {
    idx = 0;
    player.activePetIndex = 0;
  }
  const active = pets[idx];
  const others = pets.filter((_, i) => i !== idx);
  let atk = active.atk || 0;
  let luck = active.luck || 0;
  for (const p of others) {
    atk += (p.atk || 0) * 0.15;
    luck += (p.luck || 0) * 0.15;
  }
  player.pet = active;
  return { atk, luck, active, others };
}

function hasPetType(player, type) {
  ensurePet(player);
  return (player.pets || []).some(p => p.type === type);
}

function grantPet(player, type) {
  ensurePet(player);
  const def = PET_SHOP[type];
  if (!def && type !== ADMIN_PET.key) return null;

  if (type !== ADMIN_PET.key) {
    if (hasPetType(player, type)) return null;
    const pet = {
      type: def.key,
      name: def.label,
      level: 1,
      xp: 0,
      atk: def.atk,
      luck: def.luck
    };
    player.pets.push(pet);
    if (player.activePetIndex === -1) player.activePetIndex = player.pets.length - 1;
    player.pet = player.pets[player.activePetIndex];
    return pet;
  } else {
    const pet = {
      type: ADMIN_PET.key,
      name: ADMIN_PET.label,
      level: 1,
      xp: 0,
      atk: ADMIN_PET.atk,
      luck: ADMIN_PET.luck
    };
    if (!hasPetType(player, ADMIN_PET.key)) {
      player.pets.push(pet);
    }
    if (player.activePetIndex === -1) {
      player.activePetIndex = player.pets.length - 1;
    } else {
      const idx = player.pets.findIndex(p => p.type === ADMIN_PET.key);
      if (idx !== -1) player.activePetIndex = idx;
    }
    player.pet = player.pets[player.activePetIndex];
    return pet;
  }
}

function gainPetXP(player, amount) {
  ensurePet(player);
  if (!player.pets.length) return;
  const idx = player.activePetIndex;
  if (idx < 0 || idx >= player.pets.length) return;
  const pet = player.pets[idx];
  if (typeof pet.xp !== "number") pet.xp = 0;
  pet.xp += amount;
}

/* --- GÃ¶rev havuzu --- */
const QUEST_POOL = [
  {
    key: "slotPlay",
    desc: "BugÃ¼n en az 3 kez slot oyna",
    target: 3,
    reward: { chips: 3000 }
  },
  {
    key: "rouletteWin",
    desc: "BugÃ¼n rulette 1 kez kazan",
    target: 1,
    reward: { chips: 4500 }
  },
  {
    key: "bjPlay",
    desc: "BugÃ¼n 2 el blackjack oyna",
    target: 2,
    reward: { chips: 3750 }
  },
  {
    key: "dailyClaim",
    desc: "BugÃ¼nkÃ¼ gÃ¼nlÃ¼k Ã¶dÃ¼lÃ¼nÃ¼ al",
    target: 1,
    reward: { chips: 1750 }
  },
  {
    key: "huntTimes",
    desc: "BugÃ¼n 5 kez .hunt yap",
    target: 5,
    reward: { chips: 3750 }
  },
  {
    key: "boxOpen",
    desc: "BugÃ¼n 2 kutu aÃ§",
    target: 2,
    reward: { chips: 4500 }
  }
];

function shuffleArray(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function ensureQuests(player) {
  const today = localDateKey();
  if (
    !player.quests ||
    player.quests.date !== today ||
    !Array.isArray(player.quests.activeKeys) ||
    player.quests.activeKeys.length === 0
  ) {
    const allKeys = QUEST_POOL.map(q => q.key);
    const shuffled = shuffleArray(allKeys);
    const active = shuffled.slice(0, 3);
    player.quests = {
      date: today,
      activeKeys: active,
      progress: {},
      completed: {}
    };
  }
}
function applyQuestProgress(player, key, amount) {
  if (!amount || amount <= 0) return;
  ensureQuests(player);
  const qState = player.quests;
  if (!qState.activeKeys.includes(key)) return;

  const def = QUEST_POOL.find(q => q.key === key);
  if (!def) return;

  const prev = qState.progress[key] || 0;
  const now = prev + amount;
  qState.progress[key] = now;

  if (!qState.completed[key] && now >= def.target) {
    qState.completed[key] = true;
    const rewardChips = def.reward?.chips || 0;
    if (rewardChips > 0) {
      player.stack += rewardChips;
    }
  }
}

/* --- Unvanlar --- */
const TITLE_DEFS = [
  {
    key: "yeni_maceraci",
    name: "ğŸ†• Yeni MaceracÄ±",
    desc: "Oyuna katÄ±ldÄ±n.",
    check: (p) => !!p.joined
  },
  {
    key: "zengin_oyuncu",
    name: "ğŸ’° Zengin Oyuncu",
    desc: "Bakiyen 50.000 Ã§ipi geÃ§ti.",
    check: (p) => p.stack >= 50000
  },
  {
    key: "slot_ustasi",
    name: "ğŸ° Slot UstasÄ±",
    desc: "Slotta toplam +10.000 Ã§ip net kazandÄ±n.",
    check: (p) => (p.stats?.slotNetWin || 0) >= 10000
  },
  {
    key: "rulet_ustasi",
    name: "ğŸ¡ Rulet UstasÄ±",
    desc: "Rulette 10 kez kazandÄ±n.",
    check: (p) => (p.stats?.rouletteWins || 0) >= 10
  },
  {
    key: "bj_efsanesi",
    name: "ğŸƒ Blackjack Efsanesi",
    desc: "Blackjack'te 20 kez kazandÄ±n.",
    check: (p) => (p.stats?.bjWins || 0) >= 20
  },
  {
    key: "sadik_oyuncu",
    name: "ğŸ“… SadÄ±k Oyuncu",
    desc: "7 farklÄ± gÃ¼nde gÃ¼nlÃ¼k Ã¶dÃ¼l aldÄ±n.",
    check: (p) => (p.stats?.dailyDays || 0) >= 7
  },
  {
    key: "yeni_avci",
    name: "ğŸª¶ Yeni AvcÄ±",
    desc: "En az 1 kez .hunt yaptÄ±n.",
    check: (p) => (p.stats?.huntCount || 0) >= 1
  },
  {
    key: "usta_avci",
    name: "ğŸ¦´ Usta AvcÄ±",
    desc: "100 kez .hunt yaptÄ±n.",
    check: (p) => (p.stats?.huntCount || 0) >= 100
  },
  {
    key: "kutu_delisi",
    name: "ğŸ Kutu Delisi",
    desc: "50 kutu aÃ§tÄ±n.",
    check: (p) => (p.stats?.boxesOpened || 0) >= 50
  },
  {
    key: "pet_sahibi",
    name: "ğŸ¾ Pet Sahibi",
    desc: "Ä°lk petini aldÄ±n.",
    check: (p) => !!(p.pet || (p.pets && p.pets.length > 0))
  },
  {
    key: "owo_efsanesi",
    name: "ğŸŒ€ OwO Efsanesi",
    desc: "BirÃ§ok unvan aÃ§tÄ±n.",
    check: (p) => (p.titles?.owned?.length || 0) >= 5
  },
  {
    key: "admin_lord",
    name: "ğŸ‘‘ Sunucu Lordu",
    desc: "YÃ¶neticiye Ã¶zel prestij unvanÄ±.",
    check: (_p) => false
  }
];

function ensureTitles(player) {
  if (!player.titles || typeof player.titles !== "object") {
    player.titles = { owned: [], activeKey: null };
  } else {
    if (!Array.isArray(player.titles.owned)) player.titles.owned = [];
    if (typeof player.titles.activeKey !== "string" && player.titles.activeKey !== null) {
      player.titles.activeKey = null;
    }
  }
}

function getOwnedTitleObjects(player) {
  ensureTitles(player);
  return TITLE_DEFS.filter(def => player.titles.owned.includes(def.key));
}

function getActiveTitleName(player) {
  if (!player.titles || !player.titles.activeKey) return null;
  const def = TITLE_DEFS.find(d => d.key === player.titles.activeKey);
  return def ? def.name : null;
}

async function checkAndUnlockTitles(msg, player) {
  ensureStats(player);
  ensureTitles(player);
  ensurePet(player);
  const newly = [];
  for (const def of TITLE_DEFS) {
    if (def.check(player) && !player.titles.owned.includes(def.key)) {
      player.titles.owned.push(def.key);
      newly.push(def);
    }
  }
  if (newly.length > 0) {
    await saveDB();
    const lines = newly.map(d => `â€¢ ${d.name} â€” ${d.desc}`);
    if (msg) {
      await msg.reply(
`ğŸ– *Yeni Unvan(lar) KazandÄ±n!*

${lines.join("\n")}

Aktif unvanÄ±nÄ± deÄŸiÅŸtirmek iÃ§in:
.unvan â€” Unvan listesi
.unvan set <numara> â€” Unvan seÃ§`
      );
    }
  }
}

/* ===== OwO tarzÄ± Ã¶ÄŸretici metni ===== */
const OWO_HELP =
`ğŸ¾ *OwO TarzÄ± Oyun Sistemi Nedir?*

Bu bot, Discord'daki OwO botundan esinlenmiÅŸ bir *ekonomi ve mini oyun* sistemidir.
AmaÃ§: Ã§ip biriktirmek, oyunlar oynayÄ±p kazanmak, gÃ¼nlÃ¼k gÃ¶revleri tamamlayÄ±p *unvanlar* ve *petler* toplamaktÄ±r.

ğŸ® *Temel Komutlar*
â€¢ .join â€” Oyuna katÄ±l, baÅŸlangÄ±Ã§ Ã§ipini al
â€¢ .bakiye â€” Bakiyeni ve aktif unvanÄ±nÄ± gÃ¶r
â€¢ .profil â€” Genel profilini ve istatistiklerini gÃ¶r
â€¢ .stats â€” KiÅŸisel istatistiklerini gÃ¶sterir
â€¢ .stats all â€” TÃ¼m oyuncularÄ±n genel (global) istatistiklerini gÃ¶sterir
â€¢ .seviye â€” Seviyeni ve XP ilerlemeni gÃ¶r
â€¢ .top seviye â€” En yÃ¼ksek seviyedeki oyuncularÄ± gÃ¶r
â€¢ .gÃ¼nlÃ¼k â€” GÃ¼nlÃ¼k Ã§ip Ã¶dÃ¼lÃ¼nÃ¼ al
â€¢ .slot <miktar> â€” Slot makinesi oynarsÄ±n
â€¢ .rulet <miktar> <seÃ§im> â€” Rulet oynarsÄ±n (Ã¶rn: .rulet 100 kÄ±rmÄ±zÄ±)
â€¢ .bj <miktar> â€” Blackjack oyunu baÅŸlatÄ±r
â€¢ .hunt â€” Avlan, Ã§ip ve kutu bul (pet bonuslarÄ±yla daha da gÃ¼Ã§lÃ¼)
â€¢ .kutu â€” Elindeki kutularÄ± aÃ§
â€¢ .kutu all â€” TÃ¼m kutularÄ± tek seferde aÃ§
â€¢ .gÃ¶rev â€” BugÃ¼ne Ã¶zel rastgele 3 gÃ¶revi gÃ¶sterir
â€¢ .unvan â€” UnvanlarÄ±nÄ± listele / seÃ§
â€¢ .pet â€” Pet sistemini ve petini yÃ¶net
â€¢ .owo â€” Bu rehberi tekrar gÃ¶sterir

ğŸ¾ *Pet Sistemi (Ã‡oklu Pet)*

ArtÄ±k birden fazla pet alabilirsin!

SatÄ±n alÄ±nabilen pet Ã¶rnekleri (kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe):
â€¢ ğŸ¦— Ã‡ekirge â€” 6000 Ã§ip
â€¢ ğŸœ Karinca â€” 8000 Ã§ip
â€¢ ğŸ¼ Panda â€” 16000 Ã§ip
â€¢ ğŸ KeÃ§i â€” 24000 Ã§ip
â€¢ ğŸ´ At â€” 30000 Ã§ip
â€¢ ğŸ¦“ Zebra â€” 36000 Ã§ip
â€¢ ğŸ± Kedi â€” 40000 Ã§ip
â€¢ ğŸ° TavÅŸan â€” 44000 Ã§ip
â€¢ ğŸ¶ KÃ¶pek â€” 50000 Ã§ip
â€¢ ğŸ¦… Kartal â€” 60000 Ã§ip
â€¢ ğŸ¦› Su AygÄ±rÄ± â€” 64000 Ã§ip
â€¢ ğŸ˜ Fil â€” 80000 Ã§ip
â€¢ ğŸ¦Š Tilki â€” 90000 Ã§ip
â€¢ ğŸ¦ Gergedan â€” 120000 Ã§ip
â€¢ ğŸ† Ã‡ita â€” 150000 Ã§ip
â€¢ ğŸ¦ Aslan â€” 200000 Ã§ip (efsane gÃ¼Ã§)
â€¢ ğŸ‰ Ejderha â€” 400000 Ã§ip (efsane pet)

Kutudan Ã§Ä±kan *Ã¶zel* petler:
â€¢ ğŸ¢ KaplumbaÄŸa (Koleksiyon) â€” Sadece kutudan Ã§Ä±kar.
â€¢ ğŸŒ Salyangoz (Ã–zel) â€” Sadece kutudan Ã§Ä±kar. Hunt drop ÅŸansÄ±nÄ± arttÄ±rÄ±r.
â€¢ ğŸ¨ Koala (Efsane) â€” Sadece kutudan Ã§Ä±kar. Bot aÃ§Ä±kken her 30 dakikada bir +3000 Ã§ip pasif gelir kazandÄ±rÄ±r.

Komutlar:
â€¢ .pet â€” Aktif petini ve Ã¶zetini gÃ¶sterir
â€¢ .pet al <tÃ¼r> â€” Pet satÄ±n al (Ã¶rn: .pet al kedi)
â€¢ .pet liste â€” TÃ¼m sahip olduÄŸun petleri listele
â€¢ .pet set <numara> â€” Listeden bir peti *aktif* yap
â€¢ .pet isim <yeni_ad> â€” Aktif petine isim ver
â€¢ .pet shop â€” TÃ¼m petleri ve Ã¶zelliklerini gÃ¶r

ğŸ”§ *Mekanik:*
â€¢ Sadece *1 pet* aktif olur (gÃ¼cÃ¼nÃ¼n %100'Ã¼ gelir).
â€¢ DiÄŸer tÃ¼m sahip olduÄŸun petler toplam gÃ¼ce *%15* katkÄ± saÄŸlar (ATK & LUCK).
â€¢ Aktif pet XP kazanÄ±r; hunt ve kutu aÃ§tÄ±kÃ§a XP birikir.

ğŸ“¦ *Kutu & Ã–zel Pet Drop OranlarÄ±*
Kutu aÃ§arken Ã§ok dÃ¼ÅŸÃ¼k ihtimalle Ã¶zel pet kazanabilirsin:
â€¢ ğŸ¢ KaplumbaÄŸa: ~%0.3
â€¢ ğŸŒ Salyangoz: ~%0.2
â€¢ ğŸ¨ Koala: ~%0.1 (en nadir)

AyrÄ±ca bir *pity sistemi* var:
â€¢ Toplam 500+ kutu aÃ§Ä±p hÃ¢lÃ¢ bu Ã¶zel petlerden hiÃ§ alamadÄ±ysan,
  sistem sana *garanti bir Ã¶zel pet* hediye eder. (Sadece ilk kez iÃ§in.)

ğŸ“œ *GÃ¼nlÃ¼k GÃ¶revler*
â€¢ .gÃ¶rev â€” BugÃ¼ne Ã¶zel rastgele gÃ¶revler:
  - 3 kez slot oyna
  - 2 el blackjack oyna
  - 5 kez .hunt yap
  - 2 kutu aÃ§
  GÃ¶revler tamamlanÄ±nca otomatik Ã§ip Ã¶dÃ¼lÃ¼ eklenir.

ğŸ– *Unvan Sistemi*
â€¢ OynadÄ±kÃ§a sistem seni takip eder ve otomatik unvan aÃ§arsÄ±n:
  - ğŸ†• Yeni MaceracÄ± â†’ Oyuna katÄ±ldÄ±ÄŸÄ±nda
  - ğŸ’° Zengin Oyuncu â†’ 50.000+ Ã§ipin olduÄŸunda
  - ğŸ° Slot UstasÄ± â†’ Slotta Ã§ok kazandÄ±ÄŸÄ±nda
  - ğŸ¡ Rulet UstasÄ± â†’ Rulette defalarca kazandÄ±ÄŸÄ±nda
  - ğŸƒ Blackjack Efsanesi â†’ Blackjack'te ustalaÅŸtÄ±ÄŸÄ±nda
  - ğŸª¶ Yeni AvcÄ± / ğŸ¦´ Usta AvcÄ± â†’ Hunt yaptÄ±kÃ§a
  - ğŸ Kutu Delisi â†’ Bir sÃ¼rÃ¼ kutu aÃ§tÄ±ÄŸÄ±nda
  - ğŸ¾ Pet Sahibi â†’ Ä°lk petini aldÄ±ÄŸÄ±nda
  - ğŸ“… SadÄ±k Oyuncu â†’ FarklÄ± gÃ¼nlerde gÃ¼nlÃ¼k Ã¶dÃ¼l aldÄ±ÄŸÄ±nda

â€¢ .unvan â€” UnvanlarÄ±nÄ± listele
â€¢ .unvan set <numara> â€” Aktif olarak gÃ¶stermek istediÄŸin unvanÄ± seÃ§

ğŸ‘‘ *YÃ¶netici Ã–zel*
â€¢ .pet adminkurt â†’ Adminâ€™e Ã¶zel Alfa Kurt peti (ATK/LUCK 999)
â€¢ .unvan admin â†’ Adminâ€™e Ã¶zel Sunucu Lordu unvanÄ±nÄ± aÃ§ar
â€¢ .eventbuff â†’ 15 dk boyunca hunt & kutu kazancÄ±nÄ± arttÄ±ran etkinlik baÅŸlatÄ±r

ğŸ’¡ *Taktik*
Her gÃ¼n:
1) .join (bir kereye mahsus)
2) .gÃ¼nlÃ¼k al
3) .slot / .rulet / .bj / .hunt ile oyna
4) .kutu veya .kutu all ile kutularÄ± aÃ§
5) .gÃ¶rev ile gÃ¶revlerini takip et
6) .pet al ile pet koleksiyonunu bÃ¼yÃ¼t, .pet set ile aktif petini ayarla
7) .unvan ile havalÄ± unvanÄ±nÄ± seÃ§ ğŸ˜`;

/* ==================== Oyuncu yapÄ±sÄ± ==================== */
function getPlayer(id, name) {
  if (!db.data.players[id]) {
    db.data.players[id] = {
      name,
      stack: STARTING_STACK,
      lastDaily: "",
      locked: false,
      joined: false,
      stats: undefined,
      quests: undefined,
      titles: undefined,
      inv: undefined,
      pets: undefined,
      activePetIndex: undefined,
      pet: undefined,
      specialPityUsed: false
    };
  } else {
    const p = db.data.players[id];
    if (name && !p.name) p.name = name;
    if (typeof p.joined !== "boolean") p.joined = false;
    if (typeof p.locked !== "boolean") p.locked = false;
    if (typeof p.stack !== "number") p.stack = STARTING_STACK;
    if (typeof p.lastDaily !== "string") p.lastDaily = "";
    if (typeof p.specialPityUsed !== "boolean") p.specialPityUsed = false;
  }
  const p = db.data.players[id];
  ensureStats(p);
  ensureQuests(p);
  ensureTitles(p);
  ensureInventory(p);
  ensurePet(p);
  return p;
}

/* --- Oyuna katÄ±lÄ±m ÅŸartÄ± kontrolÃ¼ --- */
async function requireJoined(msg, player) {
  if (player.joined) return true;
  await msg.reply("ğŸŸ Oyuna katÄ±lmak iÃ§in `.join` yaz.");
  return false;
}
/* --- Mesaj sahibine gÃ¶re stabil oyun anahtarÄ± Ã¼retir --- */
function makeGameKey(msg, s) {
  const chat = (msg.from || "").split("@")[0];
  const author = (msg.author || "").split("@")[0];
  if (s.phoneId) return `p:${s.phoneId}`;
  if (author)  return `g:${chat}:${author}`;
  return `c:${chat}`;
}

/* ====== LID uyumlu gÃ¶nderen Ã§Ã¶zÃ¼mleyici ====== */
async function resolveSender(msg) {
  const authorId = msg.author || "";
  const fromId   = msg.from   || "";
  const authorUser = authorId.split("@")[0];
  const fromUser   = fromId.split("@")[0];
  const contact = await msg.getContact().catch(() => null);
  let number = null;
  try { number = contact && (await contact.getNumber?.()); } catch {}
  const widUser = contact?.id?.user || null;
  const phoneCandidate = number || widUser || null;
  const lidCandidate   = authorUser || fromUser || null;
  return {
    phoneId: phoneCandidate ? normPhone(phoneCandidate) : null,
    phoneIdLast10: phoneCandidate ? phoneCandidate.replace(/\D/g, "").slice(-10) : null,
    lid: lidCandidate || null
  };
}

/* ====== Tek hedef Ã§Ã¶zÃ¼cÃ¼ ====== */
const samePerson = (a, b) => last10(a) === last10(b);

async function resolveSingleTarget(msg) {
  const foundMentions = [];
  const foundReply = [];
  const foundNumbers = [];
  const foundInternal = [];

  try {
    const mentions = (await msg.getMentions?.()) || [];
    for (const c of mentions) {
      let n = null;
      try { n = await c.getNumber?.(); } catch {}
      const u = c?.id?.user || null;
      const cand = n || u;
      if (cand) {
        const pn = normPhone(cand);
        if (!foundMentions.some(x => samePerson(x, pn))) foundMentions.push(pn);
      }
    }
  } catch {}

  try {
    const quoted = await msg.getQuotedMessage?.();
    if (quoted) {
      const qc = await quoted.getContact?.();
      let qn = null;
      try { qn = await qc.getNumber?.(); } catch {}
      const qu = qc?.id?.user || null;
      const cand = qn || qu;
      if (cand) {
        const pn = normPhone(cand);
        if (!foundReply.some(x => samePerson(x, pn))) foundReply.push(pn);
      }
    }
  } catch {}

  const words = (msg.body || "").split(/\s+/);
  for (const w of words) {
    const d = (w || "").replace(/\D/g, "");
    if (d.length >= 10 && d.length <= 15) {
      const pn = normPhone(d);
      if (!foundNumbers.some(x => samePerson(x, pn))) foundNumbers.push(pn);
    }
  }

  try {
    const raw = msg?._data?.mentionedIds || msg?.mentionedIds || [];
    for (const r of raw) {
      const u = String(r).split("@")[0];
      if (u) {
        const pn = normPhone(u);
        if (!foundInternal.some(x => samePerson(x, pn))) foundInternal.push(pn);
      }
    }
  } catch {}

  const pickUnique = (arr) => {
    const out = [];
    for (const p of arr) if (!out.some(x => samePerson(x, p))) out.push(p);
    return out;
  };

  const m = pickUnique(foundMentions);
  if (m.length === 1) return { ok: true, id: m[0] };
  if (m.length > 1) return { ok: false, reason: "multi", message: `âš ï¸ Birden fazla kiÅŸi algÄ±landÄ± (${m.map(x => last10(x)).join(", ")}). LÃ¼tfen *tek* bir kiÅŸi belirt.` };

  const r = pickUnique(foundReply);
  if (r.length === 1) return { ok: true, id: r[0] };
  if (r.length > 1) return { ok: false, reason: "multi", message: `âš ï¸ Birden fazla kiÅŸi algÄ±landÄ± (${r.map(x => last10(x)).join(", ")}). LÃ¼tfen *tek* bir kiÅŸi belirt.` };

  const n = pickUnique(foundNumbers);
  if (n.length === 1) return { ok: true, id: n[0] };
  if (n.length > 1) return { ok: false, reason: "multi", message: `âš ï¸ Birden fazla kiÅŸi algÄ±landÄ± (${n.map(x => last10(x)).join(", ")}). LÃ¼tfen *tek* bir kiÅŸi belirt.` };

  const i = pickUnique(foundInternal);
  if (i.length === 1) return { ok: true, id: i[0] };
  if (i.length > 1) return { ok: false, reason: "multi", message: `âš ï¸ Birden fazla kiÅŸi algÄ±landÄ± (${i.map(x => last10(x)).join(", ")}). LÃ¼tfen *tek* bir kiÅŸi belirt.` };

  return {
    ok: false,
    reason: "none",
    message: "âš ï¸ Hedef bulunamadÄ±. *Tek* bir @kiÅŸi etiketle, numarasÄ±nÄ± yaz ya da kiÅŸinin mesajÄ±nÄ± *yanÄ±tlayarak* gÃ¶nder."
  };
}

/* ====== Mentionâ€™lardan toplu Ã§Ä±karÄ±cÄ± ====== */
function onlyDigits(s){ return (s||"").replace(/\D/g,""); }
async function extractMentionedIds(msg) {
  try {
    const contacts = (await msg.getMentions?.()) || [];
    const fromMentions = await Promise.all(contacts.map(async (c) => {
      let n = null;
      try { n = await c.getNumber?.(); } catch {}
      const u = c?.id?.user || null;
      const cand = n || u;
      return cand ? normPhone(cand) : null;
    }));
    const mentionIds = fromMentions.filter(Boolean);
    const raw = (msg.body || "")
      .split(/\s+/)
      .filter(w => /^\d{10,15}$/.test(onlyDigits(w)))
      .map(w => normPhone(w));
    return Array.from(new Set([...mentionIds, ...raw]));
  } catch {
    return [];
  }
}

/* ==================== Dedupe ==================== */
const SEEN = new Set();
function shouldProcess(msg) {
  const key = msg?.id?._serialized || msg?.id?.id || `${msg.timestamp}:${msg.from}`;
  if (SEEN.has(key)) return false;
  SEEN.add(key);
  setTimeout(() => SEEN.delete(key), 60_000);
  return true;
}

/* ==== Transfer dedupe ==== */
const DONE_TX = new Set();

/* ==================== Oyun Durumu & YardÄ±mcÄ±lar ==================== */
const animations = ["ğŸ‚ ğŸ’«", "ğŸƒâœ¨", "ğŸ’¥ğŸ‚¡", "ğŸ´ğŸŒ€", "ğŸ’«ğŸ‚±", "ğŸª„ğŸ‚¾", "ğŸ’¨ğŸƒ", "ğŸ‚«ğŸ”¥"];
const games = {};

const suits = ["â™ ï¸", "â™¥ï¸", "â™¦ï¸", "â™£ï¸"];
const values = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];
function drawCard() {
  const suit = suits[Math.floor(Math.random() * suits.length)];
  const value = values[Math.floor(Math.random() * values.length)];
  return { suit, value };
}
function getHandValue(hand) {
  let value = 0, aces = 0;
  for (const card of hand) {
    if (["J", "Q", "K"].includes(card.value)) value += 10;
    else if (card.value === "A") { value += 11; aces++; }
    else value += parseInt(card.value, 10);
  }
  while (value > 21 && aces > 0) { value -= 10; aces--; }
  return value;
}
function suitDot(suit) { return (suit === "â™¥ï¸" || suit === "â™¦ï¸") ? "ğŸ”´" : "âš«"; }
function handToDotString(hand) { return hand.map(c => `${c.value}${suitDot(c.suit)}`).join(" "); }
function valueText(val) { return (val > 21) ? "BUST! ğŸ’¥" : String(val); }

/* ===== Grup yardÄ±mcÄ±larÄ± ===== */
async function isGroupAdminByMsg(msg) {
  const chat = await msg.getChat();
  if (!chat.isGroup) return { isGroup: false, isGroupAdmin: false, chat };
  const senderId = msg.author || (await msg.getContact())?.id?._serialized;
  const isGroupAdmin = (chat.participants || []).some(p =>
    p.isAdmin && (p.id?._serialized === senderId)
  );
  return { isGroup: true, isGroupAdmin, chat };
}
/* ===== Grup bazlÄ± bot aÃ§/kapa ve kurulum (!botkur / .botkapat / .botaÃ§ / .bot aÃ§ / .bot kapat) ===== */
async function handleGroupMute(msg, body) {
  await db.read();
  if (!db.data) db.data = { players: {}, groupSettings: {} };
  if (!db.data.groupSettings) db.data.groupSettings = {};

  const chat = await msg.getChat();
  if (!chat.isGroup) return false; // sadece gruplarda geÃ§erli

  const chatId = chat.id._serialized;
  const text = (body || "").trim().toLowerCase();

  const isDisableCmd = (text === ".botkapat" || text === ".bot kapat");
  const isEnableCmd  = (text === ".botaÃ§" || text === ".bot aÃ§");
  // Ä°KÄ°SÄ° BÄ°RDEN Ã‡ALIÅSIN: !botkur VE !bot kur
  const isSetupCmd   = (text === "!botkur" || text === "!bot kur");

  // Grup iÃ§in kayÄ±t yoksa varsayÄ±lan: "kurulmamÄ±ÅŸ ve kapalÄ±"
  if (!db.data.groupSettings[chatId]) {
    db.data.groupSettings[chatId] = { disabled: true, installed: false };
  }

  const groupCfg = db.data.groupSettings[chatId];
  if (typeof groupCfg.disabled !== "boolean")  groupCfg.disabled  = true;
  if (typeof groupCfg.installed !== "boolean") groupCfg.installed = false;

  // â— Sadece bot adminleri bu komutlarÄ± kullanabilsin
  if (isDisableCmd || isEnableCmd || isSetupCmd) {
    const senderInfo = await resolveSender(msg);   // telefon / lid bilgisi
    const isAdmin = isAdminCheck(senderInfo);      // SENÄ°N admin sistemin

    if (!isAdmin) {
      await msg.reply("â›” Bu komutu yalnÄ±zca *bot adminleri* kullanabilir.");
      return true; // Mesaj burada bitsin, baÅŸka komut Ã§alÄ±ÅŸmasÄ±n
    }
  }

  // !botkur â†’ bu grupta botu KUR ve AÃ‡ (zaten kuruluysa da sorun yok, yine aÃ§ar)
  if (isSetupCmd) {
    groupCfg.installed = true;
    groupCfg.disabled = false;
    db.data.groupSettings[chatId] = groupCfg;
    await saveDB();

    await msg.reply("âœ… *Bot bu grupta kuruldu ve aktifleÅŸtirildi.*");
    return true;
  }

  // .botkapat / .bot kapat â†’ botu kapat
  if (isDisableCmd) {
    if (!groupCfg.installed) {
      await msg.reply("â„¹ï¸ Bu grupta bot henÃ¼z kurulmamÄ±ÅŸ.");
      return true;
    }
    if (groupCfg.disabled) {
      await msg.reply("â„¹ï¸ Bu grupta bot zaten kapalÄ±.");
      return true;
    }

    groupCfg.disabled = true;
    db.data.groupSettings[chatId] = groupCfg;
    await saveDB();

    await msg.reply("ğŸ”• *Bu grupta bot devre dÄ±ÅŸÄ± bÄ±rakÄ±ldÄ±.*");
    return true;
  }

  // .botaÃ§ / .bot aÃ§ â†’ botu aÃ§
  if (isEnableCmd) {
    if (!groupCfg.installed) {
      await msg.reply("â„¹ï¸ Bu grupta bot henÃ¼z kurulmamÄ±ÅŸ.");
      return true;
    }
    if (!groupCfg.disabled) {
      await msg.reply("â„¹ï¸ Bu grupta bot zaten aktif.");
      return true;
    }

    groupCfg.disabled = false;
    db.data.groupSettings[chatId] = groupCfg;
    await saveDB();

    await msg.reply("âœ… *Bu grupta bot yeniden aktif!*");
    return true;
  }

  // --- Buradan sonrasÄ±: normal mesajlar iÃ§in kontrol ---

  // Grup iÃ§in bot KURULMAMIÅSA â†’ hiÃ§bir komut iÅŸlem gÃ¶rmesin
  if (!groupCfg.installed) {
    return true;
  }

  // Grup iÃ§in bot kurulmuÅŸ ama KAPALIYSA â†’ yine hiÃ§bir komut iÅŸlem gÃ¶rmesin
  if (groupCfg.disabled) {
    return true;
  }

  // Bot bu grupta kurulu ve aÃ§Ä±k â†’ diÄŸer komutlar Ã§alÄ±ÅŸabilir
  return false;
}
/* ========== YardÄ±m metni ========== */
function buildHelpText(isAdmin) {
  const userPart =
`â™£ï¸ *Komutlar*
â€¢ .join â€” Oyuna katÄ±l
â€¢ .bakiye â€” Bakiyeni gÃ¶sterir
â€¢ .profil â€” Profilini ve istatistiklerini gÃ¶sterir
â€¢ .seviye â€” Seviye ve XP ilerlemeni gÃ¶sterir
â€¢ .top seviye â€” En yÃ¼ksek seviyedeki oyuncularÄ± gÃ¶sterir
â€¢ .gÃ¼nlÃ¼k â€” GÃ¼nlÃ¼k Ã¶dÃ¼l
â€¢ .score â€” Skor tablosu  
â€¢ .stats â€” Kendi istatistiklerini gÃ¶sterir
â€¢ .stats all â€” Sunucudaki tÃ¼m oyuncularÄ±n istatistiklerini gÃ¶ster
â€¢ .slot <miktar> â€” Slot
â€¢ .bj <miktar> | .bj bet <miktar> â€” Blackjack
â€¢ .rulet <miktar> <seÃ§im> â€” Rulet (Ã¶rn: .rulet 100 kÄ±rmÄ±zÄ±)
â€¢ .hunt â€” Avlan, Ã§ip ve kutu kazan (3 sn bekleme)
â€¢ .kutu â€” Elindeki kutularÄ± aÃ§
â€¢ .kutu all â€” TÃ¼m kutularÄ± tek seferde aÃ§
â€¢ .gÃ¶rev â€” GÃ¼nlÃ¼k rastgele gÃ¶revlerini gÃ¶sterir
â€¢ .unvan â€” UnvanlarÄ±nÄ± listele / ayarla
â€¢ .pet â€” Petini gÃ¶r / al / seÃ§
â€¢ .pet liste â€” TÃ¼m petlerini listele
â€¢ .pets â€” TÃ¼m sahip olduÄŸun petleri listele
â€¢ .pet shop â€” TÃ¼m petleri ve Ã¶zelliklerini gÃ¶r
â€¢ .owo â€” OwO tarzÄ± sistemi anlatan rehber

ğŸ® Oyun iÃ§i: .hit | .stand | .db | .sur

â„¹ï¸ Ä°pucu: ".bj" tek baÅŸÄ±na yazÄ±nca kÄ±sayol menÃ¼sÃ¼ gelir. ".rulet" tek baÅŸÄ±na yazÄ±nca rulet yardÄ±mÄ±nÄ± gÃ¶rÃ¼rsÃ¼n.`;

const adminPart =
`\n\nğŸ‘‘ *YÃ¶netici KomutlarÄ±*
â€¢ .allpman â€” Herkese +5000
â€¢ .alpman â€” Kendine +15000
â€¢ !bot kur / !botkur â€” Bu grupta botu kurar ve aktifleÅŸtirir (sadece bot admini)
â€¢ .bot kapat / .botkapat â€” BulunduÄŸun grupta botu susturur (sadece bot admini)
â€¢ .bot aÃ§ / .botaÃ§ â€” Susturulan botu o grupta tekrar aÃ§ar (sadece bot admini)
â€¢ .max â€” Kendine 999999999999 Ã§ip ekler
â€¢ .listedenat @kiÅŸi â€” Skordan Ã§Ä±kar
â€¢ .bakiye reset @kiÅŸi â€” 0 yap
â€¢ .send <miktar> @kiÅŸi â€” Ã‡ip gÃ¶nder
â€¢ !everyone [mesaj] â€” Gruptaki herkesi etiketle
â€¢ !kilit â€” Sadece yÃ¶neticiler mesaj atabilsin
â€¢ !kilitaÃ§ â€” Herkese tekrar yazma izni
â€¢ .pet adminkurt â€” Adminâ€™e Ã¶zel Alfa Kurt peti (ATK/LUCK 999)
â€¢ .unvan admin â€” Adminâ€™e Ã¶zel Sunucu Lordu unvanÄ±nÄ± aÃ§ar
â€¢ .eventbuff â€” Hunt & kutu iÃ§in geÃ§ici etkinlik buffâ€™Ä± baÅŸlatÄ±r
â€¢ .isim @kiÅŸi YeniÄ°sim â€” (Oyuncu adÄ±nÄ± deÄŸiÅŸtirir)`;

  return isAdmin ? (userPart + adminPart) : userPart;
}

/* ==================== SLOT & JACKPOT ==================== */
const symbols = ["ğŸ’", "ğŸ‹", "ğŸ‰", "ğŸ‡", "ğŸ¥", "ğŸ€", "â­"];
const paytable = { "ğŸ’": 2, "ğŸ‹": 3, "ğŸ‰": 4, "ğŸ‡": 5, "ğŸ¥": 6, "ğŸ€": 8, "â­": 12 };
let jackpot = 5000;
function spinSlot() {
  const grid = Array.from({ length: 3 }, () =>
    Array.from({ length: 3 }, () => symbols[Math.floor(Math.random() * symbols.length)])
  );
  return grid;
}
function checkSlotWin(grid, bet) {
  let totalWin = 0;
  const lines = [];
  for (let r = 0; r < 3; r++) {
    if (grid[r][0] === grid[r][1] && grid[r][1] === grid[r][2]) {
      const sym = grid[r][0];
      const win = bet * paytable[sym];
      totalWin += win;
      lines.push(`â­ SatÄ±r ${r + 1}: ${sym}${sym}${sym} â†’ +${win}`);
      if (sym === "â­") {
        totalWin += jackpot;
        lines.push(`ğŸ’¥ğŸ’° JACKPOT! +${jackpot} Ã‡ip!`);
        jackpot = 5000;
      }
    }
  }
  if (totalWin === 0) jackpot += Math.floor(bet * 0.2);
  return { totalWin, lines };
}
/* ==================== RULET ==================== */
const ROULET_HELP =
`ğŸ¡ *RULET Ã–ÄRETÄ°CÄ°SÄ°* ğŸ¡

Rulet oynamak iÃ§in komut:
.rulet <miktar> <seÃ§im>

ğŸ”¢ 1) Miktar Nedir?
â€¢ Oyun iÃ§in kaÃ§ Ã§iple bahis yapacaÄŸÄ±nÄ± gÃ¶sterir.

ğŸ¯ 2) SeÃ§im Nedir?
Renk / tek-Ã§ift / 1-18 / 19-36 / dÃ¼zineler veya direkt sayÄ± (0â€“36) seÃ§ebilirsin.

ğŸ“Œ Ã–rnekler:
â€¢ .rulet 100 kÄ±rmÄ±zÄ±
â€¢ .rulet 200 tek
â€¢ .rulet 150 1-12
â€¢ .rulet 50 17
â€¢ .rulet 100 0`;

const REDS = new Set([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]);
function rouletteColor(n) {
  if (n === 0) return { name: "yeÅŸil", dot: "ğŸŸ¢" };
  if (REDS.has(n)) return { name: "kÄ±rmÄ±zÄ±", dot: "ğŸ”´" };
  return { name: "siyah", dot: "âš«" };
}
function rouletteSpin() {
  return Math.floor(Math.random() * 37);
}
function parseRoulettePick(rawTokens){
  const raw = normalizeTR(rawTokens.join(" "));
  if (!raw) return { ok:false, message: "KullanÄ±m: .rulet <miktar> <secim>. Ã–rn: .rulet 100 kirmizi" };
  const t = raw;

  const num = parseInt(t, 10);
  if (Number.isFinite(num) && num >= 0 && num <= 36) {
    return {
      ok: true, kind: "number", title: `SayÄ± ${num}`,
      test: (n)=> n === num, payout: 35
    };
  }

  if (["k","kirmizi","red"].includes(t)) {
    return { ok:true, kind:"color:red", title:"KÄ±rmÄ±zÄ±", test:(n)=> n!==0 && REDS.has(n), payout:1 };
  }
  if (["s","siyah","black"].includes(t)) {
    return { ok:true, kind:"color:black", title:"Siyah", test:(n)=> n!==0 && !REDS.has(n), payout:1 };
  }

  if (["tek","odd"].includes(t)) {
    return { ok:true, kind:"odd", title:"Tek", test:(n)=> n!==0 && n%2===1, payout:1 };
  }
  if (["cift","cif","even"].includes(t)) {
    return { ok:true, kind:"even", title:"Ã‡ift", test:(n)=> n!==0 && n%2===0, payout:1 };
  }

  if (["1-18","alt","low"].includes(t)) {
    return { ok:true, kind:"low", title:"1-18", test:(n)=> n>=1 && n<=18, payout:1 };
  }
  if (["19-36","ust","high","yuksek"].includes(t)) {
    return { ok:true, kind:"high", title:"19-36", test:(n)=> n>=19 && n<=36, payout:1 };
  }

  if (["1-12","d1","duzin1","duzine1"].includes(t)) {
    return { ok:true, kind:"dozen1", title:"1-12", test:(n)=> n>=1 && n<=12, payout:2 };
  }
  if (["13-24","d2","duzin2","duzine2"].includes(t)) {
    return { ok:true, kind:"dozen2", title:"13-24", test:(n)=> n>=13 && n<=24, payout:2 };
  }
  if (["25-36","d3","duzin3","duzine3"].includes(t)) {
    return { ok:true, kind:"dozen3", title:"25-36", test:(n)=> n>=25 && n<=36, payout:2 };
  }

  return { ok:false, message:
`âš ï¸ GeÃ§ersiz seÃ§im.
Ã–rnekler:
â€¢ .rulet 100 kÄ±rmÄ±zÄ±
â€¢ .rulet 200 tek
â€¢ .rulet 150 1-12
â€¢ .rulet 50 17
â€¢ .rulet 100 0` };
}

/* ==================== WhatsApp Client ==================== */
const client = new Client({
  authStrategy: new LocalAuth(),
  puppeteer: { headless: true, args: ["--no-sandbox", "--disable-setuid-sandbox", "--disable-dev-shm-usage"] }
});

client.on("qr", qr => qrcode.generate(qr, { small: true }));
client.on("ready", () => console.log("âœ… Bot aktif!"));
client.on("auth_failure", m => console.error("âŒ Kimlik doÄŸrulama hatasÄ±:", m));
client.on("disconnected", r => console.warn("âš ï¸ BaÄŸlantÄ± koptu:", r));

/* ==================== Ortak: Admin kontrol ==================== */
function isAdminCheck(sender) {
  const fileAdmins = readAdmins();
  const phonePool = [
    ...ADMIN_PHONES,
    ...(fileAdmins.phones || []).map(normPhone)
  ];
  if (sender.phoneId) {
    const p = sender.phoneId;
    const p10 = sender.phoneIdLast10;
    if (phonePool.some(ap => ap === p || last10(ap) === p10)) return true;
  }
  if (sender.lid) {
    if ((fileAdmins.lids || []).includes(sender.lid)) return true;
  }
  return false;
}

/* ===== Hunt cooldown (3 saniye) ===== */
const HUNT_COOLDOWN_MS = 3000;
const lastHuntTimes = {}; // keyId -> ms
 
/* ===== Slot cooldown (3 saniye) ===== */
const SLOT_COOLDOWN_MS = 3000;
const lastSlotTimes = {}; // keyId -> ms

/* ===== Kutu Ã¶zel pet drop oranlarÄ± ===== */
const SPECIAL_DROP_RATES = {
  koala: 0.001,       // %0.1
  salyangoz: 0.002,   // %0.2
  kaplumbaga: 0.003   // %0.3
};

/* ===== Koala pasif gelir sistemi ===== */
const KOALA_PASSIVE_INTERVAL_MS = 30 * 60 * 1000; // 30 dakika
const KOALA_PASSIVE_AMOUNT = 3000;

setInterval(async () => {
  try {
    if (!db.data || !db.data.players) return;
    let affected = 0;
    for (const player of Object.values(db.data.players)) {
      ensurePet(player);
      if (hasPetType(player, "koala")) {
        player.stack += KOALA_PASSIVE_AMOUNT;
        affected++;
      }
    }
    if (affected > 0) {
      await saveDB();
      console.log(`ğŸ¨ Koala pasif geliri: ${affected} oyuncuya +${KOALA_PASSIVE_AMOUNT} Ã§ip verildi.`);
    }
  } catch (err) {
    console.error("Koala pasif gelir hatasÄ±:", err);
  }
}, KOALA_PASSIVE_INTERVAL_MS);

/* ==================== Mesaj Ä°ÅŸleyici ==================== */
async function handleMessageSafe(msg) {
  if (!shouldProcess(msg)) return;

  try {
    const s = await resolveSender(msg);
    const isAdmin = isAdminCheck(s);
    const contact = await msg.getContact().catch(() => null);
    const name = contact?.pushname || contact?.name || msg._data?.notifyName || (s.phoneId || s.lid || "unknown");

    const keyId = s.phoneId || s.lid || (msg.author || msg.from);
    const player = getPlayer(keyId, name);

    if (player.stack <= 0) {
      player.stack = AUTO_TOPUP;
      await saveDB();
      try { await msg.reply(`ğŸ†“ Otomatik destek: +${AUTO_TOPUP} Ã§ip yÃ¼klendi. Bol ÅŸans!`); } catch {}
    }

    const keyGame = makeGameKey(msg, s);

    const body = (msg.body || "").trim();
    const args = body.split(/\s+/);
    const base = args[0]?.toLowerCase();
  
    // Grup iÃ§in .botkapat / .botaÃ§ kontrolÃ¼
    if (await handleGroupMute(msg, body)) return;

    if (body.toLowerCase() === "ping") { await msg.reply("pong"); return; }
    if (base === ".me") {
      return msg.reply(
        `name: ${player.name || "-"}\n` +
        `joined: ${player.joined}\n` +
        `keyId(DB): ${keyId}\nkeyGame(GAME): ${keyGame}\n` +
        `phoneId: ${s.phoneId || "-"} / last10: ${s.phoneIdLast10 || "-"}\n` +
        `lid: ${s.lid || "-"}\n` +
        `isAdmin: ${isAdmin}`
      );
    }
    if (base === ".state") {
      const g = games[keyGame];
      return msg.reply(g ? `Game var: bet=${g.bet} | P=[${g.playerHand?.length||0}] D=[${g.dealerHand?.length||0}]` : "Game yok.");
    }

    if (base === ".owo") {
      return msg.reply(OWO_HELP);
    }
    /* ==================== EVENT BUFF ==================== */
    if (base === ".eventbuff" || base === ".etkinlik") {
      if (!isAdmin) return msg.reply("ğŸš« Bu komut iÃ§in yetkin yok.");
      const sub = (args[1] || "").toLowerCase();

      if (sub === "off" || sub === "kapat" || sub === "bitir" || sub === "stop") {
        eventBuff.active = false;
        eventBuff.until = 0;
        return msg.reply("âš¡ Etkinlik buff'Ä± manuel olarak kapatÄ±ldÄ±.");
      }

      if (isEventBuffActive()) {
        return msg.reply(`âš¡ Zaten bir etkinlik buff'Ä± aÃ§Ä±k.\nKalan sÃ¼re: ${eventBuffRemainingText()}\nKapatmak iÃ§in: .eventbuff off`);
      }

      const DURATION_MIN = 15;
      eventBuff.active = true;
      eventBuff.until = Date.now() + DURATION_MIN * 60 * 1000;

      return msg.reply(
`âš¡ *Etkinlik BaÅŸladÄ±!*

Ã–nÃ¼mÃ¼zdeki ${DURATION_MIN} dakika boyunca:
â€¢ .hunt kazanÃ§larÄ± arttÄ±
â€¢ .kutu Ã¶dÃ¼lleri buff aldÄ±

Mevcut durum: ${eventBuffRemainingText()}
Kapatmak iÃ§in: .eventbuff off`
      );
    }
    /* ==================== PET SÄ°STEMÄ° ==================== */
    if (base === ".pet") {
      if (!(await requireJoined(msg, player))) return;
      ensurePet(player);

      const sub = (args[1] || "").toLowerCase();

      if (sub === "shop" || sub === "market" || sub === "magaza" || sub === "maÄŸaza") {
        const buyableList = Object.values(PET_SHOP)
          .filter(p => p.buyable)
          .sort((a, b) => a.price - b.price)
          .map(p =>
            `${p.emoji} *${p.label}*\n` +
            `   Fiyat: ${p.price} Ã§ip\n` +
            `   ATK: ${p.atk} | LUCK: ${p.luck}\n` +
            `   ${p.desc}`
          )
          .join("\n\n");

        const specialList = Object.values(PET_SHOP)
          .filter(p => !p.buyable)
          .map(p =>
            `${p.emoji} *${p.label}* (Ã–zel)\n` +
            `   ATK: ${p.atk} | LUCK: ${p.luck}\n` +
            `   ${p.desc}`
          )
          .join("\n\n");

        let adminLine = "";
        if (isAdmin) {
          adminLine =
`\n\nğŸ‘‘ *Adminâ€™e Ã–zel Pet*:
${ADMIN_PET.emoji} *${ADMIN_PET.label}*
   ATK: ${ADMIN_PET.atk} | LUCK: ${ADMIN_PET.luck}
   Sadece: .pet adminkurt komutuyla alÄ±nabilir.`;
        }

        return msg.reply(
`ğŸ¾ *PET SHOP* ğŸ¾

ğŸ’  *SatÄ±n AlÄ±nabilen Petler:*

${buyableList}

ğŸ’  *Kutudan Ã‡Ä±kan Ã–zel Petler:*

${specialList}${adminLine}

ğŸ“Œ SatÄ±n almak iÃ§in:
.pet al <tÃ¼r>
Ã–rn:
â€¢ .pet al kedi
â€¢ .pet al panda`
        );
      }

      if (!sub) {
        const power = getPetPower(player);
        if (!power.active) {
          const shopLines = Object.values(PET_SHOP)
            .filter(p => p.buyable)
            .sort((a, b) => a.price - b.price)
            .map(p =>
              `${p.emoji} *${p.label}* â€” Fiyat: ${p.price} Ã§ip\n   ATK: ${p.atk} | LUCK: ${p.luck}`
            ).join("\n\n");

          return msg.reply(
`ğŸ¾ *Pet Sistemi*

Åu an bir petin yok.

Pet alarak:
â€¢ .hunt kazancÄ±na (ATK) bonus alÄ±rsÄ±n
â€¢ Kutularda ve hunt kutu dÃ¼ÅŸme ÅŸansÄ±nda (LUCK) kÃ¼Ã§Ã¼k buff kazanÄ±rsÄ±n

ğŸ“¦ *Pet Shop* (kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe):
${shopLines}

Kutudan Ã§Ä±kan Ã¶zel petler:
â€¢ ğŸ¢ KaplumbaÄŸa (Koleksiyon)
â€¢ ğŸŒ Salyangoz (Ã–zel) â€” Hunt drop ÅŸansÄ±nÄ± arttÄ±rÄ±r.
â€¢ ğŸ¨ Koala (Efsane) â€” Bot aÃ§Ä±kken her 30 dakikada bir +3000 Ã§ip pasif gelir saÄŸlar.

Pet almak iÃ§in:
.pet al <tÃ¼r>
Ã–rn:
â€¢ .pet al kedi
â€¢ .pet al panda`
          );
        } else {
          const { active, others, atk, luck } = power;
          const def = PET_SHOP[active.type];
          const emoji = def?.emoji || (active.type === ADMIN_PET.key ? ADMIN_PET.emoji : "ğŸ¾");
          const nameLine = getPetDisplayName(active);

          let specialInfo = "";
          if (active.type === "salyangoz") {
            specialInfo =
`\n\nâ­ *Ã–zel Ã–zellik (Salyangoz)*:
â€¢ Hunt'ta kutu/drop ÅŸansÄ±nÄ± arttÄ±rÄ±r.`;
          } else if (active.type === "koala") {
            specialInfo =
`\n\nâ­ *Ã–zel Ã–zellik (Koala)*:
â€¢ Bot aÃ§Ä±k olduÄŸu sÃ¼rece her 30 dakikada bir sana +3000 Ã§ip pasif gelir kazandÄ±rÄ±r.`;
          } else if (active.type === "kaplumbaga") {
            specialInfo =
`\n\nâ­ *Ã–zel Ã–zellik (KaplumbaÄŸa)*:
â€¢ Koleksiyon peti, sadece vitrin ve pasif gÃ¼Ã§ iÃ§in.`;
          } else if (active.type === ADMIN_PET.key) {
            specialInfo =
`\n\nâ­ *Ã–zel Ã–zellik (Alfa Kurt)*:
â€¢ Admin'e Ã¶zel efsane pet.`;
          }

          const othersLine = others.length
            ? `\nDiÄŸer petlerin (pasif %15): ${others.map(p => getPetDisplayName(p)).join(", ")}`
            : "";

          return msg.reply(
`${emoji} *Pet Bilgilerin*

Aktif Pet: ${nameLine}
TÃ¼r: ${active.type || "-"}
Seviye: ${active.level || 1}
XP: ${active.xp || 0}
Aktif ATK: ${active.atk || 0}
Aktif LUCK: ${active.luck || 0}

Toplam (aktif + pasif %15) gÃ¼Ã§:
ATK: ~${Math.round(atk)}
LUCK: ~${Math.round(luck)}${othersLine}${specialInfo}

Ä°sim deÄŸiÅŸtirmek iÃ§in:
.pet isim <yeni_isim>`
          );
        }
      }

      if (sub === "liste") {
        ensurePet(player);
        const pets = player.pets || [];
        if (!pets.length) {
          return msg.reply("ğŸ¾ HenÃ¼z hiÃ§ petin yok. `.pet al <tÃ¼r>` ile alabilirsin.");
        }
        const lines = pets.map((p, i) => {
          const def = PET_SHOP[p.type];
          const emoji = def?.emoji || "ğŸ¾";
          const activeMark = (i === player.activePetIndex) ? " (aktif)" : "";
          return `${i+1}. ${emoji} ${getPetDisplayName(p)} â€” ATK: ${p.atk || 0}, LUCK: ${p.luck || 0}${activeMark}`;
        }).join("\n");
        return msg.reply(
`ğŸ¾ *Petlerin*

${lines}

Aktif peti deÄŸiÅŸtirmek iÃ§in:
.pet set <numara>`);
      }

      if (sub === "set" || sub === "sec" || sub === "seÃ§") {
        const idxStr = args[2];
        if (!idxStr) return msg.reply("KullanÄ±m: `.pet set <numara>`\nListe iÃ§in: `.pet liste`");
        const idx = parseInt(idxStr, 10);
        ensurePet(player);
        const pets = player.pets || [];
        if (!Number.isFinite(idx) || idx < 1 || idx > pets.length) {
          return msg.reply("âš ï¸ GeÃ§erli bir pet numarasÄ± gir.\nListe iÃ§in: `.pet liste`");
        }
        player.activePetIndex = idx - 1;
        player.pet = pets[player.activePetIndex];
        await saveDB();
        return msg.reply(`ğŸ¾ Aktif petin artÄ±k: ${getPetDisplayName(player.pet)}`);
      }

      if (sub === "adminkurt" || sub === "adminpet" || sub === "admin") {
        if (!isAdmin) {
          return msg.reply("ğŸš« Bu pet sadece yÃ¶neticiler iÃ§indir.");
        }
        ensurePet(player);
        const pet = grantPet(player, ADMIN_PET.key);
        if (pet) {
          player.pet = pet;
        } else {
          const idx = player.pets.findIndex(p => p.type === ADMIN_PET.key);
          if (idx !== -1) {
            player.activePetIndex = idx;
            player.pet = player.pets[idx];
          }
        }
        if (player.pet) {
          player.pet.atk = ADMIN_PET.atk;
          player.pet.luck = ADMIN_PET.luck;
        }
        await saveDB();
        await checkAndUnlockTitles(msg, player);

        return msg.reply(
`${ADMIN_PET.emoji} *Admin Peti Verildi!*


ArtÄ±k *${ADMIN_PET.label}* senin yanÄ±nda:
ATK: ${ADMIN_PET.atk}
LUCK: ${ADMIN_PET.luck}

Bu peti sadece adminler alabilir.
ğŸ¦ Bakiye deÄŸiÅŸmedi: ${player.stack}`
        );
      }

      if (sub === "al" || sub === "buy") {
        const rawType = args[2];
        if (!rawType) {
          return msg.reply(
`KullanÄ±m: .pet al <tÃ¼r>

Ã–rnek tÃ¼rler:
â€¢ cekirge
â€¢ karinca
â€¢ panda
â€¢ keci
â€¢ at
â€¢ zebra
â€¢ kedi
â€¢ tavsan
â€¢ kopek
â€¢ kartal
â€¢ suaygiri
â€¢ fil
â€¢ tilki
â€¢ gergedan
â€¢ cita
â€¢ aslan
â€¢ ejderha`
          );
        }
        const typeKey = petTypeFromInput(rawType);
        const cfg = typeKey ? PET_SHOP[typeKey] : null;
        if (!cfg || cfg.buyable === false) {
          return msg.reply(
`âš ï¸ GeÃ§ersiz veya satÄ±n alÄ±namaz pet tÃ¼rÃ¼.

SatÄ±n alÄ±nabilen Ã¶rnekler:
â€¢ cekirge, karinca, panda, keci, at, zebra, kedi, tavsan, kopek, kartal, suaygiri, fil, tilki, gergedan, cita, aslan, ejderha`
          );
        }
        if (player.stack < cfg.price) {
          return msg.reply(`ğŸš« Yetersiz bakiye. Gerekli: ${cfg.price}, Senin: ${player.stack}`);
        }

        ensurePet(player);
        player.stack -= cfg.price;
        const pet = {
          type: cfg.key,
          name: cfg.label,
          level: 1,
          xp: 0,
          atk: cfg.atk,
          luck: cfg.luck
        };
        player.pets.push(pet);
        if (player.activePetIndex === -1) player.activePetIndex = player.pets.length - 1;
        player.pet = player.pets[player.activePetIndex];

        await saveDB();
        await checkAndUnlockTitles(msg, player);

        return msg.reply(
`${cfg.emoji} *Pet SatÄ±n AlÄ±ndÄ±!*

ArtÄ±k bir petin var:
AdÄ±: ${cfg.label}
ATK: ${cfg.atk}
LUCK: ${cfg.luck}

Petin:
â€¢ .hunt kazancÄ±nÄ± artÄ±rÄ±r
â€¢ Kutulardaki Ã¶dÃ¼le ufak bonus ekler

Ä°sim vermek iÃ§in:
.pet isim <yeni_isim>

ğŸ¦ Kalan Bakiye: ${player.stack}`
        );
      }

      if (sub === "isim" || sub === "name") {
        ensurePet(player);
        if (!player.pet) {
          return msg.reply("Åu an bir petin yok. Ã–nce `.pet al <tÃ¼r>` veya admin isen `.pet adminkurt` ile pet al.");
        }
        const newName = args.slice(2).join(" ").trim();
        if (!newName) {
          return msg.reply("KullanÄ±m: `.pet isim <yeni_isim>`");
        }
        if (newName.length > 24) {
          return msg.reply("âš ï¸ Ä°sim Ã§ok uzun. Maksimum 24 karakter kullan.");
        }
        player.pet.name = newName;
        await saveDB();
        return msg.reply(`ğŸ¾ Petinin yeni adÄ±: *${newName}*`);
      }

      return msg.reply(
`ğŸ¾ Pet komutlarÄ±:
â€¢ .pet â€” Pet durumunu gÃ¶ster
â€¢ .pet al <tÃ¼r> â€” Pet satÄ±n al
â€¢ .pet liste â€” TÃ¼m petlerini listele
â€¢ .pet set <numara> â€” Aktif pet seÃ§
â€¢ .pet shop â€” TÃ¼m petleri ve Ã¶zelliklerini gÃ¶r
â€¢ .pet adminkurt â€” (Sadece admin) Ã¶zel Alfa Kurt peti
â€¢ .pet isim <yeni_isim> â€” Petine isim ver`);
    }

    if (base === ".pets") {
      if (!(await requireJoined(msg, player))) return;
      ensurePet(player);
      const pets = player.pets || [];
      if (!pets.length) {
        return msg.reply("ğŸ¾ HenÃ¼z hiÃ§ petin yok. `.pet al <tÃ¼r>` ile pet satÄ±n alabilirsin.");
      }

      const lines = pets.map((p, i) => {
        const def = PET_SHOP[p.type];
        const emoji = def?.emoji || (p.type === ADMIN_PET.key ? ADMIN_PET.emoji : "ğŸ¾");
        const activeMark = (i === player.activePetIndex) ? " â­ (Aktif)" : "";
        const name = getPetDisplayName(p);
        const level = p.level || 1;
        const atk = p.atk || 0;
        const luck = p.luck || 0;
        const xp = p.xp || 0;
        return `${i + 1}. ${emoji} *${name}*${activeMark}
   â€¢ TÃ¼r: ${p.type || "-"}
   â€¢ Seviye: ${level}
   â€¢ XP: ${xp}
   â€¢ ATK: ${atk}
   â€¢ LUCK: ${luck}`;
      }).join("\n\n");

      return msg.reply(
`ğŸ¾ *Pet Koleksiyonun* ğŸ¾

${lines}

ğŸ”¹ Aktif peti deÄŸiÅŸtirmek iÃ§in:
.pet set <numara>

ğŸ”¹ Detay gÃ¶rmek iÃ§in:
.pet`
      );
    }

    if (base === "!everyone" || base === "!kilit" || base === "!kilitaÃ§" || base === "!kilitac") {
      const { isGroup, isGroupAdmin, chat } = await isGroupAdminByMsg(msg);
      if (!isGroup) return msg.reply("â„¹ï¸ Bu komut sadece *gruplarda* kullanÄ±labilir.");

      const canModerate = isAdmin || isGroupAdmin;
      if ((base === "!kilit" || base === "!kilitaÃ§" || base === "!kilitac") && !canModerate) {
        return msg.reply("ğŸš« Bu komut iÃ§in grup yÃ¶neticisi olmalÄ±sÄ±n (ya da bot admini).");
      }

      if (base === "!everyone") {
        try {
          const participants = chat.participants || [];
          if (!participants.length) return msg.reply("âš ï¸ Grup katÄ±lÄ±mcÄ±larÄ± alÄ±namadÄ±.");
          const mentionContacts = await Promise.all(
            participants.map(p => client.getContactById(p.id._serialized))
          );
          const tagLine = participants.map(p => `@${p.id.user}`).join(" ");
          const extra = args.slice(1).join(" ").trim();
          const text = (extra ? `${extra}\n` : "") + tagLine;
          await chat.sendMessage(text, { mentions: mentionContacts });
        } catch (e) {
          console.error("!everyone hatasÄ±:", e);
          await msg.reply("âš ï¸ everyone gÃ¶nderilemedi.");
        }
        return;
      }

      if (base === "!kilit") {
        try {
          await chat.setMessagesAdminsOnly(true);
          await msg.reply("ğŸ”’ Grup *sadece yÃ¶neticilere* kilitlendi.");
        } catch (e) {
          console.error("!kilit hatasÄ±:", e);
          await msg.reply("âš ï¸ Kilitlenemedi. Botun *grup yÃ¶neticisi* olmasÄ± gerekebilir.");
        }
        return;
      }

      if (base === "!kilitaÃ§" || base === "!kilitac") {
        try {
          await chat.setMessagesAdminsOnly(false);
          await msg.reply("ğŸ”“ Grup yeniden *herkese* aÃ§Ä±ldÄ±.");
        } catch (e) {
          console.error("!kilitaÃ§ hatasÄ±:", e);
          await msg.reply("âš ï¸ Kilit aÃ§Ä±lamadÄ±. Botun *grup yÃ¶neticisi* olmasÄ± gerekebilir.");
        }
        return;
      }
    }

    if (base === ".join") {
      if (player.joined) {
        const activeTitleName = getActiveTitleName(player);
        const titleLine = activeTitleName ? `\nğŸ– Unvan: ${activeTitleName}` : "";
        return msg.reply(`âœ… Zaten katÄ±ldÄ±n.\nğŸ¦ Bakiye: ${player.stack}${titleLine}`);
      }
      player.joined = true;
      await saveDB();
      await checkAndUnlockTitles(msg, player);
      return msg.reply(
`ğŸŸ *Oyuna katÄ±ldÄ±n!*
HoÅŸ geldin ${player.name || ""} ğŸ‰
ğŸ¦ BaÅŸlangÄ±Ã§ bakiyen: ${player.stack}
Skor tablosunda gÃ¶rÃ¼nÃ¼rsÃ¼n. Bol ÅŸans!`
      );
    }

    if (
      base === ".yardÄ±m" || base === ".yardim" ||
      (base === ".bj" && ["yardÄ±m","yardim","help","menu","menÃ¼"].includes((args[1]||"").toLowerCase()))
    ) {
      return msg.reply(buildHelpText(isAdmin));
    }

    if (base === ".profil" || base === ".profile") {
      ensureStats(player);
      ensureInventory(player);
      ensurePet(player);
      ensureQuests(player);

      const activeTitleName = getActiveTitleName(player) || "Yok";

      let activePetText = "Yok";
      if (player.pet) {
        const petType = player.pet.type || "-";
        const petName = player.pet.name || petType;
        activePetText = `${petName} (${petType})`;
      }

      const qState = player.quests;
      let questLines = [];
      if (qState && Array.isArray(qState.activeKeys) && qState.activeKeys.length) {
        questLines = qState.activeKeys
          .map((key) => {
            const def = QUEST_POOL.find((q) => q.key === key);
            if (!def) return null;
            const prog = (qState.progress && qState.progress[key]) || 0;
            const done = !!(qState.completed && qState.completed[key]);
            const status = done ? "âœ…" : `â³ ${prog}/${def.target}`;
            return `â€¢ ${def.desc} â€” ${status}`;
          })
          .filter(Boolean);
      }

      const questsText = questLines.length
        ? questLines.join("\n")
        : "â€¢ BugÃ¼n iÃ§in gÃ¶rev bulunamadÄ±. Detay iÃ§in .gÃ¶rev yaz.";

      return msg.reply(
`ğŸ‘¤ *Profil Bilgileri*

Ad: ${player.name || "-"}
ğŸ¦ Bakiye: ${player.stack}
ğŸ– Aktif Unvan: ${activeTitleName}
ğŸ¾ Aktif Pet: ${activePetText}

ğŸ“Š *Genel Ä°statistikler*
â€¢ Slot oyunlarÄ±: ${player.stats.slotGames}
â€¢ Slot net kazanÃ§: ${player.stats.slotNetWin}
â€¢ Rulet galibiyetleri: ${player.stats.rouletteWins}/${player.stats.rouletteGames}
â€¢ BJ galibiyetleri: ${player.stats.bjWins}/${player.stats.bjGames}
â€¢ Hunt sayÄ±sÄ±: ${player.stats.huntCount}
â€¢ AÃ§Ä±lan kutu: ${player.stats.boxesOpened}
â€¢ GÃ¼nlÃ¼k alÄ±nan gÃ¼n sayÄ±sÄ±: ${player.stats.dailyDays}

ğŸ“œ *BugÃ¼nkÃ¼ GÃ¶revler*
${questsText}

ğŸ”¹ Komutlar:
â€¢ .bakiye â€” Sadece bakiyeni gÃ¶r
â€¢ .gÃ¶rev â€” GÃ¶rev detaylarÄ±nÄ± ayrÄ± gÃ¶ster
â€¢ .unvan â€” UnvanlarÄ±nÄ± yÃ¶net
â€¢ .pet â€” Pet detaylarÄ±`
      );
    }

     if (
      base === ".istatistik" ||
      base === ".istatistikler" ||
      base === ".istatistic" ||
      base === ".stats"
    ) {
      const sub = (args[1] || "").toLowerCase();

      // --- GLOBAL Ä°STATÄ°STÄ°KLER (.stats all / .stats genel / .stats global) ---
      if (base === ".stats" && (sub === "all" || sub === "genel" || sub === "global")) {
        const allPlayers = Object.values(db.data.players || {});

        let totalPlayers = allPlayers.length;
        let joinedPlayers = 0;
        let totalStack = 0;

        let totalSlotGames = 0;
        let totalSlotNetWin = 0;
        let totalRouletteGames = 0;
        let totalRouletteWins = 0;
        let totalRouletteLosses = 0;
        let totalBjGames = 0;
        let totalBjWins = 0;
        let totalBjLosses = 0;
        let totalHuntCount = 0;
        let totalHuntProfit = 0;
        let totalBoxesOpened = 0;
        let totalBoxesInventory = 0;
        let totalDailyDays = 0;

        for (const p of allPlayers) {
          ensureStats(p);
          ensureInventory(p);

          totalStack += p.stack || 0;
          if (p.joined) joinedPlayers++;

          const s = p.stats || {};
          totalSlotGames      += s.slotGames       || 0;
          totalSlotNetWin     += s.slotNetWin      || 0;
          totalRouletteGames  += s.rouletteGames   || 0;
          totalRouletteWins   += s.rouletteWins    || 0;
          totalRouletteLosses += s.rouletteLosses  || 0;
          totalBjGames        += s.bjGames         || 0;
          totalBjWins         += s.bjWins          || 0;
          totalBjLosses       += s.bjLosses        || 0;
          totalHuntCount      += s.huntCount       || 0;
          totalHuntProfit     += s.huntProfit      || 0;
          totalBoxesOpened    += s.boxesOpened     || 0;
          totalDailyDays      += s.dailyDays       || 0;
          totalBoxesInventory += (p.inv && p.inv.boxes) || 0;
        }

        const avgStack = totalPlayers ? Math.round(totalStack / totalPlayers) : 0;

        return msg.reply(
`ğŸ“Š *GLOBAL OYUN Ä°STATÄ°STÄ°KLERÄ°* ğŸ“Š

ğŸ‘¥ Toplam kayÄ±tlÄ± oyuncu: ${totalPlayers}
ğŸŸ¢ Oyuna katÄ±lmÄ±ÅŸ oyuncu: ${joinedPlayers}
ğŸ’° Toplam bakiye: ${totalStack}
ğŸ’³ Oyuncu baÅŸÄ± ortalama bakiye: ${avgStack}

ğŸ° *Slot*
â€¢ Toplam oyun: ${totalSlotGames}
â€¢ Toplam net kazanÃ§: ${totalSlotNetWin}

ğŸ¡ *Rulet*
â€¢ Toplam oyun: ${totalRouletteGames}
â€¢ Kazanma: ${totalRouletteWins}
â€¢ Kaybetme: ${totalRouletteLosses}

ğŸƒ *Blackjack*
â€¢ Toplam el: ${totalBjGames}
â€¢ Kazanma: ${totalBjWins}
â€¢ Kaybetme: ${totalBjLosses}

ğŸ¹ *Hunt*
â€¢ Toplam hunt: ${totalHuntCount}
â€¢ Toplam kazanÃ§: ${totalHuntProfit}

ğŸ *Kutu*
â€¢ Toplam aÃ§Ä±lan kutu: ${totalBoxesOpened}
â€¢ Envanterdeki kutular: ${totalBoxesInventory}

ğŸ“… *GÃ¼nlÃ¼k*
â€¢ Toplam alÄ±nan gÃ¼nlÃ¼k Ã¶dÃ¼l: ${totalDailyDays}`
        );
      }

      // --- KÄ°ÅÄ°SEL Ä°STATÄ°STÄ°K (.stats / .istatistik) ---
      if (!(await requireJoined(msg, player))) return;

      ensureStats(player);
      ensureInventory(player);
      ensurePet(player);
      ensureTitles(player);

      const s = player.stats || {};
      const { level, totalXp } = calculatePlayerLevel(player);

      const rouletteWinRate = s.rouletteGames
        ? Math.round((s.rouletteWins / s.rouletteGames) * 100)
        : 0;

      const bjWinRate = s.bjGames
        ? Math.round((s.bjWins / s.bjGames) * 100)
        : 0;

      const avgHuntProfit = s.huntCount
        ? Math.round(s.huntProfit / s.huntCount)
        : 0;

      const titlesCount = (player.titles?.owned?.length) || 0;
      const petsCount = (player.pets?.length) || 0;
      const boxesOwned = player.inv?.boxes || 0;

      return msg.reply(
`ğŸ“Š *DetaylÄ± Ä°statistikler*

ğŸ‘¤ Oyuncu: ${player.name || "-"}
ğŸ¦ Bakiye: ${player.stack}
â­ Seviye: ${level} (XP: ${totalXp})

ğŸ° *Slot*
â€¢ Oynanan oyun: ${s.slotGames}
â€¢ Net kazanÃ§: ${s.slotNetWin}

ğŸ¡ *Rulet*
â€¢ Oynanan oyun: ${s.rouletteGames}
â€¢ Kazanma: ${s.rouletteWins}
â€¢ Kaybetme: ${s.rouletteLosses}
â€¢ Kazanma oranÄ±: ${rouletteWinRate}%

ğŸƒ *Blackjack*
â€¢ Oynanan el: ${s.bjGames}
â€¢ Kazanma: ${s.bjWins}
â€¢ Kaybetme: ${s.bjLosses}
â€¢ Kazanma oranÄ±: ${bjWinRate}%

ğŸ¹ *Hunt*
â€¢ Hunt sayÄ±sÄ±: ${s.huntCount}
â€¢ Toplam kazanÃ§: ${s.huntProfit}
â€¢ Ortalama kazanÃ§: ${avgHuntProfit}

ğŸ *Kutu*
â€¢ AÃ§Ä±lan kutu: ${s.boxesOpened}
â€¢ Envanterdeki kutu: ${boxesOwned}

ğŸ“… *GÃ¼nlÃ¼k*
â€¢ GÃ¼nlÃ¼k Ã¶dÃ¼l aldÄ±ÄŸÄ±n gÃ¼n sayÄ±sÄ±: ${s.dailyDays}

ğŸ– Unvan sayÄ±sÄ±: ${titlesCount}
ğŸ¾ Pet sayÄ±sÄ±: ${petsCount}

â„¹ï¸ Ã–zet gÃ¶rÃ¼nÃ¼m iÃ§in: .profil`
      );
    }


    if (base === ".seviye" || base === ".level") {
      if (!(await requireJoined(msg, player))) return;

      const { level, totalXp } = calculatePlayerLevel(player);

      const levelSize = 100;
      const currentLevelBaseXp = (level - 1) * levelSize;
      const nextLevelXp = level * levelSize;
      const inLevelXp = Math.max(0, totalXp - currentLevelBaseXp);
      const inLevelMax = nextLevelXp - currentLevelBaseXp;
      const progress = Math.max(0, Math.min(1, inLevelXp / inLevelMax));

      const barTotal = 10;
      const filled = Math.round(progress * barTotal);
      const empty = barTotal - filled;
      const bar = "â–ˆ".repeat(filled) + "â–‘".repeat(empty);
      const percent = Math.round(progress * 100);

      return msg.reply(
`ğŸ“Š *Seviye Bilgilerin*

Ad: ${player.name || "-"}
Seviye: ${level}
Toplam XP: ${totalXp}

Seviye iÃ§i ilerleme:
[${bar}] ${percent}% (${inLevelXp}/${inLevelMax} XP)

Bir Ã¼st seviyeye kadar: ${nextLevelXp - totalXp} XP`
      );
    }

    if (base === ".stats" && args[0] && args[0].toLowerCase() === "all") {
      const allPlayers = Object.values(db.data.players || {});
      let totalPlayers = allPlayers.length;
      let joinedPlayers = 0;
      let totalStack = 0;

      let totalSlotGames = 0;
      let totalSlotNetWin = 0;
      let totalRouletteGames = 0;
      let totalRouletteWins = 0;
      let totalRouletteLosses = 0;
      let totalBjGames = 0;
      let totalBjWins = 0;
      let totalBjLosses = 0;
      let totalHuntCount = 0;
      let totalHuntProfit = 0;
      let totalBoxesOpened = 0;
      let totalBoxesInventory = 0;
      let totalDailyDays = 0;

      for (const p of allPlayers) {
        ensureStats(p);
        ensureInventory(p);

        totalStack += p.stack || 0;
        if (p.joined) joinedPlayers++;

        const s = p.stats || {};
        totalSlotGames     += s.slotGames      || 0;
        totalSlotNetWin    += s.slotNetWin     || 0;
        totalRouletteGames += s.rouletteGames  || 0;
        totalRouletteWins  += s.rouletteWins   || 0;
        totalRouletteLosses+= s.rouletteLosses || 0;
        totalBjGames       += s.bjGames        || 0;
        totalBjWins        += s.bjWins         || 0;
        totalBjLosses      += s.bjLosses       || 0;
        totalHuntCount     += s.huntCount      || 0;
        totalHuntProfit    += s.huntProfit     || 0;
        totalBoxesOpened   += s.boxesOpened    || 0;
        totalDailyDays     += s.dailyDays      || 0;
        totalBoxesInventory += (p.inv && p.inv.boxes) || 0;
      }

      const avgStack = totalPlayers ? Math.round(totalStack / totalPlayers) : 0;

      return msg.reply(
`ğŸ“Š *GLOBAL OYUN Ä°STATÄ°STÄ°KLERÄ°* ğŸ“Š

ğŸ‘¥ Toplam kayÄ±tlÄ± oyuncu: ${totalPlayers}
ğŸŸ¢ Oyuna katÄ±lmÄ±ÅŸ oyuncu: ${joinedPlayers}
ğŸ’° Toplam bakiye: ${totalStack}
ğŸ’³ Oyuncu baÅŸÄ± ortalama bakiye: ${avgStack}

ğŸ° *Slot*
â€¢ Toplam oyun: ${totalSlotGames}
â€¢ Toplam net kazanÃ§: ${totalSlotNetWin}

ğŸ¡ *Rulet*
â€¢ Toplam oyun: ${totalRouletteGames}
â€¢ Kazanma: ${totalRouletteWins}
â€¢ Kaybetme: ${totalRouletteLosses}

ğŸƒ *Blackjack*
â€¢ Toplam el: ${totalBjGames}
â€¢ Kazanma: ${totalBjWins}
â€¢ Kaybetme: ${totalBjLosses}

ğŸ¹ *Hunt*
â€¢ Toplam hunt: ${totalHuntCount}
â€¢ Toplam kazanÃ§: ${totalHuntProfit}

ğŸ *Kutu*
â€¢ Toplam aÃ§Ä±lan kutu: ${totalBoxesOpened}
â€¢ Envanterdeki kutular: ${totalBoxesInventory}

ğŸ“… *GÃ¼nlÃ¼k*
â€¢ Toplam alÄ±nan gÃ¼nlÃ¼k Ã¶dÃ¼l: ${totalDailyDays}`
      );
    }


    if (base === ".seviye" || base === ".level") {
      if (!(await requireJoined(msg, player))) return;

      const { level, totalXp } = calculatePlayerLevel(player);

      const levelSize = 100;
      const currentLevelBaseXp = (level - 1) * levelSize;
      const nextLevelXp = level * levelSize;
      const inLevelXp = Math.max(0, totalXp - currentLevelBaseXp);
      const inLevelMax = nextLevelXp - currentLevelBaseXp;
      const progress = Math.max(0, Math.min(1, inLevelXp / inLevelMax));

      const barTotal = 10;
      const filled = Math.round(progress * barTotal);
      const empty = barTotal - filled;
      const bar = "â–ˆ".repeat(filled) + "â–‘".repeat(empty);
      const percent = Math.round(progress * 100);

      return msg.reply(
`ğŸ“Š *Seviye Bilgilerin*

Ad: ${player.name || "-"}
Seviye: ${level}
Toplam XP: ${totalXp}

Seviye iÃ§i ilerleme:
[${bar}] ${percent}% (${inLevelXp}/${inLevelMax} XP)

Bir Ã¼st seviyeye kadar: ${nextLevelXp - totalXp} XP`
      );
    }

    if (base === ".bakiye" && (args[1]||"").toLowerCase() === "reset") {
      if (!isAdmin) return msg.reply("ğŸš« Bu komut iÃ§in yetkin yok.");
      const tgt = await resolveSingleTarget(msg);
      if (!tgt.ok) return msg.reply(tgt.message);
      const tid = tgt.id;
      const tp = getPlayer(tid, db.data.players[tid]?.name || tid);
      tp.stack = 0;
      await saveDB();
      return msg.reply(`ğŸ§° ${tp.name || tid} iÃ§in bakiye *0* yapÄ±ldÄ±.`);
    }

    if ((base === ".bakiye" && args.length === 1) ||
        (base === ".bj" && ["bakiye","balance"].includes((args[1]||"").toLowerCase()) && args.length === 2)) {
      const activeTitleName = getActiveTitleName(player);
      const titleLine = activeTitleName ? `\nğŸ– Unvan: ${activeTitleName}` : "";
      return msg.reply(
        `ğŸ¦ *Bakiye:* ${player.stack} Ã§ip${player.locked ? " (ğŸ”’ kilitli)" : ""}` +
        titleLine +
        `${player.joined ? "" : "\nâ„¹ï¸ Skor tablosuna girmek iÃ§in \`.join\` yaz."}`
      );
    }

    if (base === ".score" || base === ".skor" || base === ".scores" || base === ".lb" ||
       (base === ".bj" && ["skor","score","scores","leaderboard","lb"].includes((args[1]||"").toLowerCase()))) {
      const items = Object.entries(db.data.players)
        .map(([pid, p]) => ({ id: pid, name: p.name || pid, stack: p.stack, joined: !!p.joined }))
        .filter(p => p.joined)
        .sort((a,b) => b.stack - a.stack)
        .slice(0, 10);
      const lines = items.map((p, i) => `${i+1}. ${p.name} â€” ${p.stack}`);
      return msg.reply(`ğŸ“œ *Skor Tablosu (KatÄ±lanlar - Top 10)*\n` + (lines.length ? lines.join("\n") : "â€” HenÃ¼z kimse katÄ±lmadÄ±. \`.join\` yaz!"));
    }

    if (base === ".top" && ["seviye", "sev"].includes((args[1] || "").toLowerCase())) {
      const allPlayers = Object.entries(db.data.players || {}).map(([pid, p]) => {
        const { level, totalXp } = calculatePlayerLevel(p);
        return {
          name: p.name || pid,
          joined: !!p.joined,
          level,
          totalXp
        };
      });

      const joinedPlayers = allPlayers
        .filter(p => p.joined)
        .sort((a, b) => {
          if (b.level !== a.level) return b.level - a.level;
          return b.totalXp - a.totalXp;
        })
        .slice(0, 10);

      if (!joinedPlayers.length) {
        return msg.reply("ğŸ“ˆ HenÃ¼z oyuna katÄ±lan kimse yok. `.join` yazarak baÅŸlayabilirsin.");
      }

      const lines = joinedPlayers.map((p, i) =>
        `${i + 1}. ${p.name} â€” Seviye ${p.level} (XP: ${p.totalXp})`
      );

      return msg.reply(
`ğŸ“ˆ *Top Seviye Oyuncular* (Sadece katÄ±lanlar)

${lines.join("\n")}`
      );
    }

    if (base === ".gÃ¶rev" || base === ".gorev" || base === ".quest") {
      if (!(await requireJoined(msg, player))) return;
      ensureQuests(player);
      const qState = player.quests;
      const activeKeys = qState.activeKeys || [];

      if (!activeKeys.length) {
        return msg.reply("BugÃ¼n iÃ§in gÃ¶rev bulunamadÄ±, lÃ¼tfen tekrar deneyin.");
      }

      const lines = activeKeys.map((key, i) => {
        const def = QUEST_POOL.find(q => q.key === key);
        if (!def) return `${i + 1}. (Bilinmeyen gÃ¶rev)`;
        const prog = qState.progress[key] || 0;
        const done = !!qState.completed[key];
        const status = done ? "âœ… TamamlandÄ±" : `â³ ${prog}/${def.target}`;
        const rewardChips = def.reward?.chips || 0;
        const rewardText = rewardChips > 0 ? `Ã–dÃ¼l: +${rewardChips} Ã§ip` : "";
        return `${i+1}. ${def.desc}\n   Durum: ${status}\n   ${rewardText}`;
      });

      return msg.reply(
`ğŸ“œ *GÃ¼nlÃ¼k GÃ¶revler* (Her oyuncu iÃ§in her gÃ¼n rastgele seÃ§ilir)

${lines.join("\n\n")}`
      );
    }

    if (base === ".unvan" || base === ".unvanlar" || base === ".title" || base === ".titles") {
      if (!(await requireJoined(msg, player))) return;
      ensureTitles(player);
      await checkAndUnlockTitles(msg, player);
      const sub = (args[1] || "").toLowerCase();

      const owned = getOwnedTitleObjects(player);
      const activeName = getActiveTitleName(player);

      if (sub === "admin") {
        if (!isAdmin) {
          return msg.reply("ğŸš« Bu unvan sadece yÃ¶neticiler iÃ§indir.");
        }
        const adminDef = TITLE_DEFS.find(t => t.key === "admin_lord");
        if (!player.titles.owned.includes("admin_lord")) {
          player.titles.owned.push("admin_lord");
        }
        player.titles.activeKey = "admin_lord";
        await saveDB();
        return msg.reply(`ğŸ‘‘ Admin unvanÄ±n aktif edildi: ${adminDef?.name || "Sunucu Lordu"}`);
      }

      if (!sub) {
        if (!owned.length) {
          return msg.reply(
`ğŸ– *UnvanlarÄ±n*
HenÃ¼z hiÃ§ unvanÄ±n yok.
Oyun oynadÄ±kÃ§a sistem otomatik olarak sana unvan verecek.`
          );
        }
        const list = owned.map((t, i) =>
          `${i+1}. ${t.name} â€” ${t.desc}${t.name === activeName ? " (aktif)" : ""}`
        ).join("\n");
        const adminHint = isAdmin
          ? `\n\nğŸ‘‘ Admin isen Ã¶zel unvan iÃ§in:\n.unvan admin`
          : "";
        return msg.reply(
`ğŸ– *UnvanlarÄ±n*
Aktif: ${activeName || "Yok"}

${list}

Aktif unvanÄ± deÄŸiÅŸtirmek iÃ§in:
.unvan set <numara>${adminHint}`
        );
      }

      if (sub === "set" || sub === "sec" || sub === "seÃ§") {
        const sel = args[2];
        if (!sel) {
          return msg.reply("KullanÄ±m: `.unvan set <numara>`\nÃ–nce liste gÃ¶rmek iÃ§in: `.unvan`");
        }
        const idx = parseInt(sel, 10);
        if (!Number.isFinite(idx) || idx < 1 || idx > owned.length) {
          return msg.reply("âš ï¸ GeÃ§erli bir unvan numarasÄ± gir.\nListe gÃ¶rmek iÃ§in: `.unvan`");
        }
        const chosen = owned[idx - 1];
        player.titles.activeKey = chosen.key;
        await saveDB();
        return msg.reply(`ğŸ– Aktif unvanÄ±n artÄ±k: ${chosen.name}`);
      }

      return msg.reply("KullanÄ±m: `.unvan` (liste) | `.unvan set <numara>` (aktif et) | (admin iÃ§in) `.unvan admin`");
    }

    if (base === ".allpman" || (base === ".bj" && (args[1]||"").toLowerCase() === "allpman")) {
      if (!isAdmin) return msg.reply("ğŸš« Bu komut iÃ§in yetkin yok.");
      Object.values(db.data.players).forEach(p => { p.stack += 5000; });
      await saveDB();
      return msg.reply("ğŸ’¸ TÃ¼m oyunculara +5000 Ã§ip eklendi.");
    }

    if (base === ".alpman") {
      if (!isAdmin) return msg.reply("ğŸš« Bu komut iÃ§in yetkin yok.");
      player.stack += 15000;
      await saveDB();
      await checkAndUnlockTitles(msg, player);
      return msg.reply(`âœ… Kendine +15000 Ã§ip eklendi.\nğŸ¦ *Bakiye:* ${player.stack}`);
    }

    if (base === ".max") {
      if (!isAdmin) return msg.reply("ğŸš« Bu komut iÃ§in yetkin yok.");
      const ADD_AMOUNT = 999_999_999_999;
      player.stack += ADD_AMOUNT;
      await saveDB();
      await checkAndUnlockTitles(msg, player);
      return msg.reply(`âœ… +${ADD_AMOUNT} Ã§ip eklendi.\nğŸ¦ *Bakiye:* ${player.stack}`);
    }

    if (base === ".listedenat") {
      if (!isAdmin) return msg.reply("ğŸš« Bu komut iÃ§in yetkin yok.");
      const targets = await extractMentionedIds(msg);
      if (!targets.length) return msg.reply("âš ï¸ Listeden atmak iÃ§in @kiÅŸi belirt.");
      let count = 0;
      for (const tid of targets) {
        const tp = getPlayer(tid, db.data.players[tid]?.name || tid);
        if (tp.joined) { tp.joined = false; count++; }
      }
      await saveDB();
      return msg.reply(`ğŸ—‘ï¸ Skor listesinden Ã§Ä±karÄ±ldÄ±: ${count} kiÅŸi.`);
    }
     if (base === ".isim" || base === ".ad") {
      const rest = args.slice(1).join(" ").trim();
      if (!rest) {
        return msg.reply(
`KullanÄ±m:
â€¢ Kendi adÄ±nÄ± deÄŸiÅŸtirmek iÃ§in: .isim Yeni Ä°sim
â€¢ (Admin) baÅŸkasÄ±nÄ±n adÄ±nÄ± deÄŸiÅŸtirmek iÃ§in: .isim @kiÅŸi Yeni Ä°sim`
        );
      }

      // Mesajda mention varsa â†’ admin baÅŸkasÄ±nÄ± deÄŸiÅŸtiriyor
      const hasMention = (msg.body || "").includes("@");

      // SADECE KENDÄ° ADINI DEÄÄ°ÅTÄ°RME (mention YOKSA)
      if (!hasMention) {
        if (rest.length > 30) {
          return msg.reply("âš ï¸ Ä°sim Ã§ok uzun. Maksimum 30 karakter kullan.");
        }
        const oldName = player.name || "-";
        player.name = rest;
        await saveDB();
        return msg.reply(
`âœ… Ä°smin gÃ¼ncellendi!

Eski: ${oldName}
Yeni: ${player.name}

ğŸ“œ .score listesinde de yeni ismin gÃ¶rÃ¼necek.`
        );
      }

      // BURAYA GELDÄ°YSE: mention VAR â†’ SADECE ADMIN KULLANABÄ°LÄ°R
      if (!isAdmin) {
        return msg.reply("ğŸš« BaÅŸkasÄ±nÄ±n ismini sadece admin deÄŸiÅŸtirebilir.");
      }

      const tgt = await resolveSingleTarget(msg);
      if (!tgt.ok) {
        return msg.reply(tgt.message);
      }

      // Yeni ismi, mention ve numaralarÄ± ayÄ±klayarak al
      const cleanWords = args.slice(1).filter(w => {
        if (w.startsWith("@")) return false;
        const d = w.replace(/\D/g, "");
        if (d.length >= 5) return false;
        return true;
      });
      const newName = cleanWords.join(" ").trim();
      if (!newName) {
        return msg.reply("âš ï¸ Yeni ismi yazmayÄ± unutma. Ã–rn: .isim @kiÅŸi Yeni Ä°sim");
      }
      if (newName.length > 30) {
        return msg.reply("âš ï¸ Ä°sim Ã§ok uzun. Maksimum 30 karakter kullan.");
      }

      const tid = tgt.id;
      const tp = getPlayer(tid, db.data.players[tid]?.name || tid);
      const oldName = tp.name || tid;
      tp.name = newName;
      await saveDB();

      return msg.reply(
`âœ… Oyuncu ismi gÃ¼ncellendi (ADMIN)

Eski: ${oldName}
Yeni: ${tp.name}

ğŸ“œ .score ve diÄŸer yerlerde bu isim gÃ¶rÃ¼necek.`
      );
    }

    if (base === ".admin") {
      const sub = (args[1] || "").toLowerCase();
      if (sub === "addme") {
        const pin = (args[2] || "").trim();
        if (!pin || pin !== ADMIN_PIN) return msg.reply("ğŸ” PIN hatalÄ±.");
        const fileAdmins = readAdmins();
        const s2 = await resolveSender(msg);
        if (s2.phoneId) {
          if (!fileAdmins.phones.includes(s2.phoneId)) fileAdmins.phones.push(s2.phoneId);
          writeAdmins(fileAdmins);
          return msg.reply(`âœ… Admin eklendi (telefon): ${s2.phoneId}`);
        } else if (s2.lid) {
          if (!fileAdmins.lids.includes(s2.lid)) fileAdmins.lids.push(s2.lid);
          writeAdmins(fileAdmins);
          return msg.reply(`âœ… Admin eklendi (LID): ${s2.lid}`);
        } else {
          return msg.reply("âš ï¸ Kimlik Ã§Ã¶zÃ¼mlenemedi.");
        }
      }
      if (sub === "delme") {
        const pin = (args[2] || "").trim();
        if (!pin || pin !== ADMIN_PIN) return msg.reply("ğŸ” PIN hatalÄ±.");
        const fileAdmins = readAdmins();
        let changed = false;
        const s2 = await resolveSender(msg);
        if (s2.phoneId) {
          const before = fileAdmins.phones.length;
          fileAdmins.phones = fileAdmins.phones.filter(p => p !== s2.phoneId);
          changed = changed || before !== fileAdmins.phones.length;
        }
        if (s2.lid) {
          const beforeL = fileAdmins.lids.length;
          fileAdmins.lids = fileAdmins.lids.filter(l => l !== s2.lid);
          changed = changed || beforeL !== fileAdmins.lids.length;
        }
        writeAdmins(fileAdmins);
        return msg.reply(changed ? "ğŸ—‘ï¸ Admin kaydÄ±n silindi." : "â„¹ï¸ KayÄ±t bulunamadÄ±.");
      }
      if (sub === "list") {
        const fileAdmins = readAdmins();
        return msg.reply(
          `ğŸ‘‘ Admin listesi\n` +
          `ENV phones: ${ADMIN_PHONES.join(", ") || "-"}\n` +
          `FILE phones: ${(fileAdmins.phones || []).join(", ") || "-"}\n` +
          `FILE lids: ${(fileAdmins.lids || []).join(", ") || "-"}`
        );
      }
      return msg.reply("KullanÄ±m: `.admin addme <PIN>` | `.admin delme <PIN>` | `.admin list`");
    }

    if (base === ".bj" && args.length === 1) {
      return msg.reply(buildHelpText(isAdmin));
    }
 
if (base === ".bj") {
  const sub = (args[1] || "").toLowerCase();

  // ğŸ”’ Yeni oyun aÃ§ma kontrolÃ¼
  const numericArg1 = parseInt(args[1], 10);
  const isStartNewGame =
    sub === "bet" ||                // .bj bet 1000
    Number.isFinite(numericArg1);   // .bj 1000

  if (isStartNewGame && games[keyGame]) {
    return msg.reply(
      "âš ï¸ Zaten devam eden bir blackjack oyunun var.\n" +
      "Ã–nce o oyunu `.hit`, `.stand`, `.db` veya `.sur` ile bitir."
    );
  }

  // ---------- .bj bet <miktar> ----------
  if (sub === "bet") {
    if (!(await requireJoined(msg, player))) return;

    const bet = parseInt(args[2], 10);
    if (!Number.isFinite(bet) || bet < MIN_BET) {
      return msg.reply(`âš ï¸ Minimum bahis ${MIN_BET} Ã§ip.`);
    }
    if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");
    if (player.stack < bet) return msg.reply("ğŸš« Yetersiz bakiye!");

    const playerHand = [drawCard(), drawCard()];
    const dealerHand = [drawCard(), drawCard()];
    games[keyGame] = {
      bet,
      playerHand,
      dealerHand,
      canDouble: true,
      surrendered: false
    };
    const val = getHandValue(playerHand);

    return msg.reply(
`ğŸ´ *BLACKJACK* ğŸ´

ğŸƒ *DaÄŸÄ±tÄ±cÄ±:* ${dealerHand[0].value}${suitDot(dealerHand[0].suit)} â“
ğŸ‘¤ *Sen:* ${handToDotString(playerHand)} â€” (${valueText(val)})

ğŸ’µ *Bahis:* ${bet}
â¡ï¸ Komutlar: .hit | .stand | .db | .sur`
    );
  }

  // ---------- .bj <miktar> ----------
  const maybeBet = numericArg1;
  if (Number.isFinite(maybeBet)) {
    if (!(await requireJoined(msg, player))) return;

    if (maybeBet < MIN_BET) {
      return msg.reply(`âš ï¸ Minimum bahis ${MIN_BET} Ã§ip.`);
    }
    if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");
    if (player.stack < maybeBet) return msg.reply("ğŸš« Yetersiz bakiye!");

    const playerHand = [drawCard(), drawCard()];
    const dealerHand = [drawCard(), drawCard()];
    games[keyGame] = {
      bet: maybeBet,
      playerHand,
      dealerHand,
      canDouble: true,
      surrendered: false
    };
    const val = getHandValue(playerHand);

   return msg.reply(
`ğŸ´ *BLACKJACK* ğŸ´

âš¡ *Hareket:* ğŸƒ Yeni Oyun BaÅŸladÄ±

ğŸƒ *DaÄŸÄ±tÄ±cÄ±:* ${dealerHand[0].value}${suitDot(dealerHand[0].suit)} â“
ğŸ“Š *DeÄŸer:* ?

ğŸ‘¤ *.:* ${handToDotString(playerHand)}
ğŸ“Š *DeÄŸer:* ${valueText(val)}

ğŸ’µ *Bahis:* ${maybeBet} ğŸ’°
ğŸ¦ *Bakiye:* ${player.stack} ğŸ’°

â¡ï¸ Komutlar: .hit | .stand | .db | .sur`
  );

  }
}

      if (base === ".hit") {
      const game = games[makeGameKey(msg, s)];
      if (!game) return;
      if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");

      const anim = animations[Math.floor(Math.random() * animations.length)];
      await msg.reply(`${anim} Kart Ã§ekiliyor...`);
      await new Promise(res => setTimeout(res, 900));

      game.playerHand.push(drawCard());
      game.canDouble = false;
      const val = getHandValue(game.playerHand);

      if (val > 21) {
        delete games[makeGameKey(msg, s)];
        player.stack -= game.bet;
        ensureStats(player);
        player.stats.bjGames += 1;
        player.stats.bjLosses += 1;
        applyQuestProgress(player, "bjPlay", 1);
        await saveDB();
        await checkAndUnlockTitles(msg, player);
        return msg.reply(
`ğŸ´ *BLACKJACK* ğŸ´

âš¡ *Hareket:* ğŸ’¥ Oyun Bitti

ğŸƒ *DaÄŸÄ±tÄ±cÄ±:* ${handToDotString(game.dealerHand)}
ğŸ“Š *DeÄŸer:* ${getHandValue(game.dealerHand)}

ğŸ‘¤ *.:* ${handToDotString(game.playerHand)}
ğŸ“Š *DeÄŸer:* BUST! ğŸ’¥

ğŸ’µ *Bahis:* ${game.bet} ğŸ’°
ğŸ¦ *Bakiye:* ${player.stack} ğŸ’°

âŒ Kaybettin -${game.bet}`
        );
      }

      return msg.reply(
`ğŸ´ *BLACKJACK* ğŸ´

âš¡ *Hareket:* Kart Ã‡ekildi

ğŸƒ *DaÄŸÄ±tÄ±cÄ±:* ${game.dealerHand[0].value}${suitDot(game.dealerHand[0].suit)} â“
ğŸ“Š *DeÄŸer:* ?

ğŸ‘¤ *.:* ${handToDotString(game.playerHand)}
ğŸ“Š *DeÄŸer:* ${valueText(val)}

ğŸ’µ *Bahis:* ${game.bet} ğŸ’°
ğŸ¦ *Bakiye:* ${player.stack} ğŸ’°`
      );
    }

    if (base === ".db") {
      const game = games[makeGameKey(msg, s)];
      if (!game) return;
      if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");
      if (!game.canDouble) return msg.reply("âš ï¸ Double sadece ilk iki karttan sonra ve hiÃ§ hit yapmadan mÃ¼mkÃ¼ndÃ¼r.");
      if (player.stack < game.bet) return msg.reply("ğŸš« Yetersiz bakiye (double iÃ§in aynÄ± miktar gerekir).");

      player.stack -= game.bet;
      game.bet *= 2;
      game.playerHand.push(drawCard());
      game.canDouble = false;

      let dealerVal = getHandValue(game.dealerHand);
      while (dealerVal < 17) {
        game.dealerHand.push(drawCard());
        dealerVal = getHandValue(game.dealerHand);
      }
      const playerVal = getHandValue(game.playerHand);

      let outcome = "push";
      let result;
      if (playerVal > 21) {
        outcome = "lose";
        result = `ğŸ˜ Kaybettin -${game.bet}`;
      } else if (dealerVal > 21 || playerVal > dealerVal) {
        outcome = "win";
        player.stack += game.bet * 2;
        result = `ğŸ† KazandÄ±n! +${game.bet}`;
      } else if (playerVal < dealerVal) {
        outcome = "lose";
        result = `ğŸ˜ Kaybettin -${game.bet}`;
      } else {
        outcome = "push";
        player.stack += game.bet;
        result = `ğŸ¤ Berabere!`;
      }

      ensureStats(player);
      player.stats.bjGames += 1;
      if (outcome === "win") player.stats.bjWins += 1;
      if (outcome === "lose") player.stats.bjLosses += 1;
      applyQuestProgress(player, "bjPlay", 1);

      await saveDB();
      delete games[makeGameKey(msg, s)];
      await checkAndUnlockTitles(msg, player);

      return msg.reply(
`ğŸ´ *BLACKJACK* ğŸ´

âš¡ *Hareket:* ğŸ’¥ Oyun Bitti

ğŸƒ *DaÄŸÄ±tÄ±cÄ±:* ${handToDotString(game.dealerHand)}
ğŸ“Š *DeÄŸer:* ${dealerVal}

ğŸ‘¤ *.:* ${handToDotString(game.playerHand)}
ğŸ“Š *DeÄŸer:* ${valueText(playerVal)}

ğŸ’µ *Bahis:* ${game.bet} ğŸ’°
ğŸ¦ *Bakiye:* ${player.stack} ğŸ’°

${result}`
      );
    }

    if (base === ".sur") {
      const game = games[makeGameKey(msg, s)];
      if (!game) return;
      if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");
      const loss = Math.ceil(game.bet / 2);
      player.stack -= loss;
      ensureStats(player);
      player.stats.bjGames += 1;
      player.stats.bjLosses += 1;
      applyQuestProgress(player, "bjPlay", 1);
      await saveDB();
      delete games[makeGameKey(msg, s)];
      await checkAndUnlockTitles(msg, player);

      return msg.reply(
`ğŸ´ *BLACKJACK* ğŸ´

âš¡ *Hareket:* ğŸ³ï¸ Oyun Bitti

ğŸƒ *DaÄŸÄ±tÄ±cÄ±:* â€” 
ğŸ“Š *DeÄŸer:* â€” 

ğŸ‘¤ *.:* â€” 
ğŸ“Š *DeÄŸer:* â€” 

ğŸ’µ *Bahis:* ${game.bet} ğŸ’°
ğŸ¦ *Bakiye:* ${player.stack} ğŸ’°

ğŸ’¸ *KayÄ±p:* -${loss}`
      );
    }

    if (base === ".stand") {
      const game = games[makeGameKey(msg, s)];
      if (!game) return;
      if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");

      let dealerVal = getHandValue(game.dealerHand);
      while (dealerVal < 17) {
        game.dealerHand.push(drawCard());
        dealerVal = getHandValue(game.dealerHand);
      }
      const playerVal = getHandValue(game.playerHand);
      let result = "";
      let outcome = "push";
      if (playerVal > 21) {
        player.stack -= game.bet;
        outcome = "lose";
        result = `ğŸ˜ Kaybettin -${game.bet}`;
      } else if (dealerVal > 21 || playerVal > dealerVal) {
        player.stack += game.bet;
        outcome = "win";
        result = `ğŸ† KazandÄ±n! +${game.bet}`;
      } else if (playerVal < dealerVal) {
        player.stack -= game.bet;
        outcome = "lose";
        result = `ğŸ˜ Kaybettin -${game.bet}`;
      } else {
        outcome = "push";
        result = `ğŸ¤ Berabere!`;
      }

      ensureStats(player);
      player.stats.bjGames += 1;
      if (outcome === "win") player.stats.bjWins += 1;
      if (outcome === "lose") player.stats.bjLosses += 1;
      applyQuestProgress(player, "bjPlay", 1);

      await saveDB();
      delete games[makeGameKey(msg, s)];
      await checkAndUnlockTitles(msg, player);

      return msg.reply(
`ğŸ´ *BLACKJACK* ğŸ´

âš¡ *Hareket:* ğŸ’¥ Oyun Bitti

ğŸƒ *DaÄŸÄ±tÄ±cÄ±:* ${handToDotString(game.dealerHand)}
ğŸ“Š *DeÄŸer:* ${dealerVal}

ğŸ‘¤ *.:* ${handToDotString(game.playerHand)}
ğŸ“Š *DeÄŸer:* ${valueText(playerVal)}

ğŸ’µ *Bahis:* ${game.bet} ğŸ’°
ğŸ¦ *Bakiye:* ${player.stack} ğŸ’°

${result}`
      );
    }

    if (base === ".send") {
      await adminSendFunds(msg, player, args.slice(1), isAdmin);
      return;
    }

    if (base === ".hunt") {
      if (!(await requireJoined(msg, player))) return;
      if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");

      const now = Date.now();
      const last = lastHuntTimes[keyId] || 0;
      const diff = now - last;
      if (diff < HUNT_COOLDOWN_MS) {
        const remainSec = Math.ceil((HUNT_COOLDOWN_MS - diff) / 1000);
        return msg.reply(`â³ Hunt iÃ§in biraz beklemelisin. ${remainSec} sn sonra tekrar dene.`);
      }
      lastHuntTimes[keyId] = now;

      ensureStats(player);
      ensureInventory(player);
      ensurePet(player);

      const power = getPetPower(player);
      const petAtk = power.atk || 0;
      const petLuck = power.luck || 0;

      const baseMin = 20 + Math.round(petAtk * 0.5);
      const baseMax = 80 + Math.round(petAtk * 0.8);
      const baseGain = randInt(baseMin, baseMax);

      let buffMult = 1;
      let buffLine = "";
      if (isEventBuffActive()) {
        buffMult = 1.5;
        buffLine = "\nâš¡ Etkinlik buff'Ä± aktif: Hunt kazancÄ± arttÄ±!";
      }

      let gain = Math.round(baseGain * buffMult);

      let baseDropChance = 0.3;
      const bonusDrop = petLuck * 0.01;
      const buffDropBonus = isEventBuffActive() ? 0.05 : 0;
      if (hasPetType(player, "salyangoz")) {
        baseDropChance += 0.05;
      }
      const boxDrop = Math.random() < (baseDropChance + bonusDrop + buffDropBonus);

      player.stack += gain;
      player.stats.huntCount += 1;
      player.stats.huntProfit += gain;

      if (boxDrop) {
        player.inv.boxes += 1;
      }

      applyQuestProgress(player, "huntTimes", 1);
      gainPetXP(player, 10);

      await saveDB();
      await checkAndUnlockTitles(msg, player);

      let extra = boxDrop
        ? `\nğŸ Av sÄ±rasÄ±nda *1 kutu* buldun! (Toplam kutu: ${player.inv.boxes})`
        : "";

      let petInfo = "";
      if (power.active) {
        petInfo =
`\n\nğŸ¾ Pet GÃ¼cÃ¼:
ATK: ~${Math.round(petAtk)} â†’ Hunt kazancÄ±nÄ± arttÄ±rÄ±r
LUCK: ~${Math.round(petLuck)} â†’ Kutu dÃ¼ÅŸme ÅŸansÄ±nÄ± yÃ¼kseltir`;
      }

      return msg.reply(
`ğŸ¹ *HUNT SONUCU* ğŸ¹

KazanÃ§: +${gain} Ã§ip${extra}
ğŸ¦ Bakiye: ${player.stack}${petInfo}${buffLine}`
      );
    }

    async function openOneBox(player, forAll) {
      ensureStats(player);
      ensureInventory(player);
      ensurePet(player);

      player.inv.boxes -= 1;
      player.stats.boxesOpened += 1;

      const roll = Math.random();
      let reward = 0;
      let flavor = "";

      if (roll < 0.05) {
        reward = randInt(800, 1500);
        flavor = "ğŸ’ *EFSANE Ã–DÃœL!*";
      } else if (roll < 0.25) {
        reward = randInt(300, 600);
        flavor = "âœ¨ GÃ¼zel bir Ã¶dÃ¼l buldun.";
      } else {
        reward = randInt(50, 200);
        flavor = "ğŸ KÃ¼Ã§Ã¼k bir Ã¶dÃ¼l Ã§Ä±ktÄ±.";
      }

      const power = getPetPower(player);
      const petLuck = power.luck || 0;

      let petBonus = 0;
      if (petLuck > 0) {
        petBonus = randInt(0, Math.round(petLuck * 5));
        reward += petBonus;
      }

      let buffBonus = 0;
      let buffLine = "";
      if (isEventBuffActive()) {
        const before = reward;
        reward = Math.round(reward * 1.4);
        buffBonus = reward - before;
        buffLine = `âš¡ Etkinlik bonusu: +${buffBonus} Ã§ip`;
      }

      player.stack += reward;
      player.stats.boxesOpened = player.stats.boxesOpened || 0;
      applyQuestProgress(player, "boxOpen", 1);
      gainPetXP(player, 5);

      let specialPetMessage = "";
      let droppedType = null;

      const alreadyHasSpecial = (player.pets || []).some(p =>
        ["kaplumbaga","salyangoz","koala"].includes(p.type)
      );

      let forced = false;
      if (!alreadyHasSpecial && !player.specialPityUsed && player.stats.boxesOpened >= 500) {
        forced = true;
      }

      if (forced) {
        const pool = ["kaplumbaga","salyangoz","koala"];
        const type = pool[Math.floor(Math.random() * pool.length)];
        const pet = grantPet(player, type);
        if (pet) {
          player.specialPityUsed = true;
          droppedType = type;
          specialPetMessage =
`\n\nğŸŒŸ *ÅansÄ±n dÃ¶ndÃ¼!* 500+ kutudan sonra Ã¶zel bir pet kazandÄ±n!
â†’ ${PET_SHOP[type].emoji} ${PET_SHOP[type].label}`;
        }
      } else {
        const r = Math.random();
        let acc = 0;
        for (const [type, rate] of Object.entries(SPECIAL_DROP_RATES)) {
          acc += rate;
          if (r < acc) {
            const pet = grantPet(player, type);
            if (pet) {
              droppedType = type;
            }
            break;
          }
        }

        if (droppedType === "koala") {
          specialPetMessage =
`\n\nğŸŒŸ *Efsane Pet bulundu!* ğŸ¨ KOALA seni seÃ§ti!`;
        } else if (droppedType === "salyangoz") {
          specialPetMessage =
`\n\nâœ¨ *Nadir Pet bulundu!* ğŸŒ Salyangoz sana geldi!`;
        } else if (droppedType === "kaplumbaga") {
          specialPetMessage =
`\n\nğŸ *Koleksiyon Pet bulundu!* ğŸ¢ KaplumbaÄŸa en sonunda gÃ¶rÃ¼ndÃ¼!`;
        }
      }

      await saveDB();
      await checkAndUnlockTitles(null, player).catch(() => {});

      return {
        reward,
        flavor,
        petBonus,
        buffBonus,
        buffLine,
        specialPetMessage
      };
    }

    if (base === ".kutu" || base === ".box") {
      if (!(await requireJoined(msg, player))) return;
      if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");

      ensureStats(player);
      ensureInventory(player);
      ensurePet(player);

      const sub = (args[1] || "").toLowerCase();

      if ((sub === "all" || sub === "hepsi") && player.inv.boxes > 0) {
        const totalBoxes = player.inv.boxes;
        let totalReward = 0;
        let totalPetBonus = 0;
        let totalBuffBonus = 0;
        let anySpecialMsg = "";

        for (let i = 0; i < totalBoxes; i++) {
          const res = await openOneBox(player, true);
          totalReward += res.reward;
          totalPetBonus += res.petBonus || 0;
          totalBuffBonus += res.buffBonus || 0;
          if (res.specialPetMessage) {
            anySpecialMsg += res.specialPetMessage;
          }
        }

        return msg.reply(
`ğŸ *TÃœM KUTULAR AÃ‡ILDI* ğŸ

AÃ§Ä±lan kutu: ${totalBoxes}
Toplam kazanÃ§: +${totalReward} Ã§ip
ğŸ¾ Pet bonuslarÄ±: +${totalPetBonus} Ã§ip
âš¡ Buff bonusu: +${totalBuffBonus} Ã§ip
Kalan kutu: ${player.inv.boxes}
ğŸ¦ Bakiye: ${player.stack}${anySpecialMsg || ""}`
        );
      }

      if (player.inv.boxes <= 0) {
        return msg.reply("ğŸ HiÃ§ kutun yok. .hunt yaparak kutu bulabilirsin.");
      }

      const res = await openOneBox(player, false);

      let petLine = "";
      if (res.petBonus > 0) {
        petLine = `\nğŸ¾ Pet bonusu: +${res.petBonus} Ã§ip`;
      }

      let buffLine = "";
      if (res.buffBonus > 0) {
        buffLine = `\n${res.buffLine}`;
      }

      return msg.reply(
`ğŸ *KUTU AÃ‡ILDI* ğŸ

${res.flavor}
KazanÃ§: +${res.reward} Ã§ip${petLine}${buffLine}
Kalan kutu: ${player.inv.boxes}
ğŸ¦ Bakiye: ${player.stack}${res.specialPetMessage || ""}`
      );
    }

    if (base === ".slot") {
  // ğŸ” Slot anti-spam (3 saniye)
  const now = Date.now();
  const last = lastSlotTimes[keyId] || 0;
  const diff = now - last;
  if (diff < SLOT_COOLDOWN_MS) {
    const remainSec = Math.ceil((SLOT_COOLDOWN_MS - diff) / 1000);
    return msg.reply(`â³ Slot iÃ§in biraz beklemelisin. ${remainSec} sn sonra tekrar dene.`);
  }
  lastSlotTimes[keyId] = now;
      const bet = parseInt(args[1], 10);
      if (!Number.isFinite(bet) || bet < MIN_BET) return msg.reply(`âš ï¸ Minimum bahis ${MIN_BET}`);
      if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");
      if (player.stack < bet) return msg.reply("ğŸš« Yetersiz bakiye!");

      const grid = spinSlot();
      const { totalWin, lines } = checkSlotWin(grid, bet);
      const net = totalWin - bet;
      player.stack += net;

      ensureStats(player);
      player.stats.slotGames += 1;
      player.stats.slotNetWin += net;
      applyQuestProgress(player, "slotPlay", 1);

      await saveDB();
      await checkAndUnlockTitles(msg, player);

      const gridText = grid.map(r => r.join(" ")).join("\n");
      const resultText = net > 0 ? `ğŸ† *KazandÄ±n!* +${net}` : `ğŸ˜ *Kaybettin* -${bet}`;
      const lineText = lines.length ? lines.join("\n") : "ğŸ”¸ HiÃ§ kazanÃ§ yok";
      const jpText = `ğŸ’° Jackpot: ${jackpot}`;

      return msg.reply(
`ğŸ° *SLOT SONUCU* ğŸ°

${gridText}

${lineText}
${resultText}
${jpText}
ğŸ’³ Bakiye: ${player.stack}`
      );
    }

    if (base === ".jackpot") {
      return msg.reply(`ğŸ’° *GÃ¼ncel Jackpot:* ${jackpot} Ã§ip ğŸ’`);
    }

    if (base === ".rulet" && args.length === 1) {
      return msg.reply(ROULET_HELP);
    }

    if (base === ".rulet") {
      if (!(await requireJoined(msg, player))) return;

      const bet = parseInt(args[1], 10);
      if (!Number.isFinite(bet) || bet < MIN_BET) {
        return msg.reply(
`ğŸ¡ *RULET YARDIMI*
KullanÄ±m: .rulet <miktar> <seÃ§im>

Ã–rnekler:
â€¢ .rulet 100 kÄ±rmÄ±zÄ±
â€¢ .rulet 200 tek
â€¢ .rulet 150 1-12
â€¢ .rulet 50 17
â€¢ .rulet 100 0`
        );
      }
      if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");
      if (player.stack < bet) return msg.reply("ğŸš« Yetersiz bakiye!");

      const pick = parseRoulettePick(args.slice(2));
      if (!pick.ok) return msg.reply(pick.message);

      const anims = ["ğŸ¡", "ğŸ¯", "ğŸŒ€", "âœ¨", "ğŸ¯", "ğŸ¡"];
      await msg.reply(`${anims[0]} Teker dÃ¶nÃ¼yor...`);
      await new Promise(r => setTimeout(r, 900));
      await msg.reply(`${anims[2]} HÄ±zlanÄ±yor...`);
      await new Promise(r => setTimeout(r, 700));

      const n = rouletteSpin();
      const col = rouletteColor(n);
      const won = pick.test(n);
      let delta;
      let info;

      if (won) {
        const profit = bet * pick.payout;
        delta = profit;
        info = pick.payout === 1
          ? `ğŸ† *KazandÄ±n!* +${profit}`
          : `ğŸ† *KazandÄ±n!* +${profit} (Ã¶deme ${pick.payout}:1)`;
      } else {
        delta = -bet;
        info = `ğŸ˜ *Kaybettin* -${bet}`;
      }

      player.stack += delta;

      ensureStats(player);
      player.stats.rouletteGames += 1;
      if (won) {
        player.stats.rouletteWins += 1;
        applyQuestProgress(player, "rouletteWin", 1);
      } else {
        player.stats.rouletteLosses += 1;
      }

      await saveDB();
      await checkAndUnlockTitles(msg, player);

      const numBadge = n === 0 ? "0 ğŸŸ¢" : `${n} ${col.dot}`;
      return msg.reply(
`ğŸ¡ *RULET SONUCU* ğŸ¡

ğŸ² *Top:* ${numBadge} (${col.name})
ğŸ¯ *SeÃ§im:* ${pick.title}
ğŸ’µ *Bahis:* ${bet}

${info}
ğŸ¦ *Bakiye:* ${player.stack}`
      );
    }

    if (base === ".gÃ¼nlÃ¼k" || base === ".gunluk" || base === ".daily") {
      if (!(await requireJoined(msg, player))) return;
      const key = localDateKey();
      if (player.lastDaily === key) return msg.reply("â³ GÃ¼nlÃ¼k Ã¶dÃ¼lÃ¼nÃ¼ zaten aldÄ±n.");
      player.lastDaily = key;
      player.stack += DAILY_REWARD;
      ensureStats(player);
      player.stats.dailyDays = (player.stats.dailyDays || 0) + 1;
      applyQuestProgress(player, "dailyClaim", 1);
      await saveDB();
      await checkAndUnlockTitles(msg, player);
      return msg.reply(`ğŸ *GÃ¼nlÃ¼k Ã¶dÃ¼l:* +${DAILY_REWARD}\nğŸ¦ Bakiye: ${player.stack}`);
    }

  } catch (err) {
    console.error("Mesaj iÅŸleme hatasÄ±:", err);
    try { await msg.reply("âš ï¸ Ä°Ã§ hata oluÅŸtu, lÃ¼tfen tekrar deneyin."); } catch {}
  }
}

/* ========== SADECE message_create DÄ°NLÄ°YORUZ ========== */
client.on("message_create", (msg) => {
  handleMessageSafe(msg);
});

// SÃ¼reklilik
process.on("uncaughtException", e => console.error("uncaughtException:", e));
process.on("unhandledRejection", e => console.error("unhandledRejection:", e));

client.initialize();

/* --- Admin para gÃ¶nderme â€” (DEDUPE EKLENDÄ°) --- */
async function adminSendFunds(msg, senderPlayer, rawArgs, isAdmin) {
  if (!isAdmin) {
    await msg.reply("ğŸš« Bu komut iÃ§in yetkin yok.");
    return;
  }
  const mid = msg?.id?._serialized || msg?.id?.id || `${msg.timestamp}:${msg.from}`;
  const txKey = `tx:${mid}`;
  if (DONE_TX.has(txKey)) return;
  DONE_TX.add(txKey);

  const amount = parseInt(rawArgs.find(a => /^\d+$/.test(a)), 10);
  if (!Number.isFinite(amount) || amount <= 0) {
    await msg.reply("âš ï¸ GeÃ§erli bir miktar gir: `.send 500 @kiÅŸi`");
    setTimeout(() => DONE_TX.delete(txKey), 60_000);
    return;
  }

  const tgt = await resolveSingleTarget(msg);
  if (!tgt.ok) {
    await msg.reply(tgt.message);
    setTimeout(() => DONE_TX.delete(txKey), 60_000);
    return;
  }
  const tid = tgt.id;

  if (senderPlayer.stack < amount) {
    await msg.reply(`ğŸš« Yetersiz bakiye. Gerekli: ${amount}, Senin: ${senderPlayer.stack}`);
    setTimeout(() => DONE_TX.delete(txKey), 60_000);
    return;
  }

  const tp = getPlayer(tid, db.data.players[tid]?.name || tid);
  senderPlayer.stack -= amount;
  tp.stack += amount;
  await saveDB();

  await msg.reply(
    `âœ… GÃ¶nderildi: ${tp.name || tid} â†’ +${amount}\n` +
    `ğŸ’³ Kalan bakiyen: ${senderPlayer.stack}`
  );

  setTimeout(() => DONE_TX.delete(txKey), 60_000);
}
