import wwjs from "whatsapp-web.js";
const { Client, LocalAuth } = wwjs;
import qrcode from "qrcode-terminal";
import fs from "fs";
import path from "path";
import dotenv from "dotenv";
import { Low } from "lowdb";
import { JSONFile } from "lowdb/node";

dotenv.config();

/* ==================== Telefon YardÄ±mcÄ±larÄ± ==================== */
function normPhone(raw) {
  const d = (raw || "").replace(/\D/g, "");
  if (d.startsWith("90") && d.length === 12) return d;       // 90xxxxxxxxxx
  if (d.startsWith("0") && d.length === 11) return "9" + d;  // 0xxxxxxxxxx -> 90xxxxxxxxxx
  if (d.length === 10) return "90" + d;                      // xxxxxxxxxx  -> 90xxxxxxxxxx
  return d;
}
function last10(s) {
  const d = (s || "").replace(/\D/g, "");
  return d.slice(-10);
}

/* ==================== DB Kurulumu ==================== */
const DATA_DIR = process.env.DATA_DIR || "./data";
if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });

const dbFile = path.join(DATA_DIR, "players.json");
const adapter = new JSONFile(dbFile);
const db = new Low(adapter, { players: {} });

await (async () => {
  try { await db.read(); }
  catch {
    db.data = { players: {} };
    await db.write();
  }
})();
if (!db.data) db.data = { players: {} };

const STARTING_STACK = parseInt(process.env.STARTING_STACK || "100", 10);
const MIN_BET = parseInt(process.env.MIN_BET || "5", 10);
/* --- GÃœNCELLENDÄ°: gÃ¼nlÃ¼k Ã¶dÃ¼l varsayÄ±lan 1000 --- */
const DAILY_REWARD = parseInt(process.env.DAILY_REWARD || "1000", 10);
/* >>> ENVâ€™den ayarlanabilir otomatik destek (varsayÄ±lan 3000) <<< */
const AUTO_TOPUP = parseInt(process.env.AUTO_TOPUP || "3000", 10);

/* ==== Admin yapÄ±landÄ±rma (.env + kalÄ±cÄ± dosya) ==== */
const ADMIN_PIN = (process.env.ADMIN_PIN || "1234").trim();
const ADMIN_PHONES = (process.env.ADMIN_PHONES || process.env.ADMIN_PHONE || "")
  .split(",")
  .map(s => s.trim())
  .filter(Boolean)
  .map(normPhone);

// KalÄ±cÄ± admin dosyasÄ±
const adminsFile = path.join(DATA_DIR, "admins.json");
if (!fs.existsSync(adminsFile)) {
  fs.writeFileSync(adminsFile, JSON.stringify({ phones: [], lids: [] }, null, 2), "utf8");
}
function readAdmins() {
  try { return JSON.parse(fs.readFileSync(adminsFile, "utf8")); }
  catch { return { phones: [], lids: [] }; }
}
function writeAdmins(obj) {
  fs.writeFileSync(adminsFile, JSON.stringify(obj, null, 2), "utf8");
}

/* ==================== Utils ==================== */
function localDateKey(ms = Date.now(), tz = "Europe/Istanbul") {
  return new Date(ms).toLocaleDateString("tr-TR", { timeZone: tz });
}
async function saveDB() { await db.write(); }

/* Basit random int yardÄ±mcÄ±sÄ± */
function randInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

/* ===== Global Event Buff (admin etkinliÄŸi) ===== */
let eventBuff = {
  active: false,
  until: 0
};

function isEventBuffActive() {
  if (!eventBuff.active) return false;
  if (Date.now() >= eventBuff.until) {
    eventBuff.active = false;
    eventBuff.until = 0;
    return false;
  }
  return true;
}

function eventBuffRemainingText() {
  if (!isEventBuffActive()) return "kapalÄ±";
  const ms = eventBuff.until - Date.now();
  const sec = Math.max(1, Math.round(ms / 1000));
  const min = Math.floor(sec / 60);
  const s = sec % 60;
  return min > 0 ? `${min} dk ${s} sn` : `${s} sn`;
}

/* ===== Ä°STATÄ°STÄ°K, ENVANTER, GÃ–REV, PET VE UNVAN SÄ°STEMÄ° ===== */

/* --- Oyuncu istatistikleri (slot, rulet, bj, gÃ¼nlÃ¼k, hunt, kutu) --- */
function ensureStats(player) {
  if (!player.stats || typeof player.stats !== "object") {
    player.stats = {
      slotGames: 0,
      slotNetWin: 0,
      rouletteGames: 0,
      rouletteWins: 0,
      rouletteLosses: 0,
      bjGames: 0,
      bjWins: 0,
      bjLosses: 0,
      dailyDays: 0,
      huntCount: 0,
      huntProfit: 0,
      boxesOpened: 0
    };
  } else {
    const s = player.stats;
    if (typeof s.slotGames !== "number") s.slotGames = 0;
    if (typeof s.slotNetWin !== "number") s.slotNetWin = 0;
    if (typeof s.rouletteGames !== "number") s.rouletteGames = 0;
    if (typeof s.rouletteWins !== "number") s.rouletteWins = 0;
    if (typeof s.rouletteLosses !== "number") s.rouletteLosses = 0;
    if (typeof s.bjGames !== "number") s.bjGames = 0;
    if (typeof s.bjWins !== "number") s.bjWins = 0;
    if (typeof s.bjLosses !== "number") s.bjLosses = 0;
    if (typeof s.dailyDays !== "number") s.dailyDays = 0;
    if (typeof s.huntCount !== "number") s.huntCount = 0;
    if (typeof s.huntProfit !== "number") s.huntProfit = 0;
    if (typeof s.boxesOpened !== "number") s.boxesOpened = 0;
  }
}

/* --- Envanter (kutu vs.) --- */
function ensureInventory(player) {
  if (!player.inv || typeof player.inv !== "object") {
    player.inv = { boxes: 0 };
  } else {
    if (typeof player.inv.boxes !== "number") player.inv.boxes = 0;
  }
}

/* --- Pet sistemi --- */
function ensurePet(player) {
  if (player.pet === undefined) {
    player.pet = null; // hiÃ§ pet yoksa null
  }
}

const PET_SHOP = {
  kedi: {
    key: "kedi",
    emoji: "ğŸ±",
    label: "Kedi",
    price: 2000,
    atk: 1,
    luck: 2,
    desc: "Dengeli, ÅŸanslÄ± kÃ¼Ã§Ã¼k bir avcÄ±. Hunt & kutuda hafif buff."
  },
  kopek: {
    key: "kopek",
    emoji: "ğŸ¶",
    label: "KÃ¶pek",
    price: 2500,
    atk: 2,
    luck: 1,
    desc: "Daha agresif, saldÄ±rÄ± aÄŸÄ±rlÄ±klÄ±. Hunt kazancÄ± biraz daha yÃ¼ksek."
  },
  ejderha: {
    key: "ejderha",
    emoji: "ğŸ‰",
    label: "Ejderha",
    price: 10000,
    atk: 5,
    luck: 5,
    desc: "Efsane pet. Hem yÃ¼ksek kazanÃ§ hem ekstra ÅŸans saÄŸlar."
  }
};

/* --- Adminâ€™e Ã¶zel pet --- */
const ADMIN_PET = {
  key: "adminkurt",
  emoji: "ğŸº",
  label: "Alfa Kurt",
  atk: 6,
  luck: 6
};

function petTypeFromInput(raw) {
  const t = normalizeTR(raw || "");
  if (["kedi","cat","pisi"].includes(t)) return "kedi";
  if (["kopek","kÃ¶pek","kope","dog"].includes(t)) return "kopek";
  if (["ejder","ejderha","dragon"].includes(t)) return "ejderha";
  return null;
}

/* --- Rastgele gÃ¶rev havuzu --- */
const QUEST_POOL = [
  {
    key: "slotPlay",
    desc: "BugÃ¼n en az 3 kez slot oyna",
    target: 3,
    reward: { chips: 200 }
  },
  {
    key: "rouletteWin",
    desc: "BugÃ¼n rulette 1 kez kazan",
    target: 1,
    reward: { chips: 300 }
  },
  {
    key: "bjPlay",
    desc: "BugÃ¼n 2 el blackjack oyna",
    target: 2,
    reward: { chips: 250 }
  },
  {
    key: "dailyClaim",
    desc: "BugÃ¼nkÃ¼ gÃ¼nlÃ¼k Ã¶dÃ¼lÃ¼nÃ¼ al",
    target: 1,
    reward: { chips: 100 }
  },
  {
    key: "huntTimes",
    desc: "BugÃ¼n 5 kez .hunt yap",
    target: 5,
    reward: { chips: 250 }
  },
  {
    key: "boxOpen",
    desc: "BugÃ¼n 2 kutu aÃ§",
    target: 2,
    reward: { chips: 300 }
  }
];

function shuffleArray(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

/* --- GÃ¼nlÃ¼k gÃ¶rev durumu (her oyuncu iÃ§in ayrÄ±) --- */
function ensureQuests(player) {
  const today = localDateKey();
  if (
    !player.quests ||
    player.quests.date !== today ||
    !Array.isArray(player.quests.activeKeys) ||
    player.quests.activeKeys.length === 0
  ) {
    const allKeys = QUEST_POOL.map(q => q.key);
    const shuffled = shuffleArray(allKeys);
    const active = shuffled.slice(0, 3); // her oyuncu iÃ§in o gÃ¼ne Ã¶zel 3 gÃ¶rev
    player.quests = {
      date: today,
      activeKeys: active,
      progress: {},
      completed: {}
    };
  }
}

/* GÃ¶reve ilerleme ekle â€” sadece o gÃ¼n aktif olan gÃ¶revlerde Ã§alÄ±ÅŸÄ±r */
function applyQuestProgress(player, key, amount) {
  if (!amount || amount <= 0) return;
  ensureQuests(player);
  const qState = player.quests;
  if (!qState.activeKeys.includes(key)) return;

  const def = QUEST_POOL.find(q => q.key === key);
  if (!def) return;

  const prev = qState.progress[key] || 0;
  const now = prev + amount;
  qState.progress[key] = now;

  if (!qState.completed[key] && now >= def.target) {
    qState.completed[key] = true;
    const rewardChips = def.reward?.chips || 0;
    if (rewardChips > 0) {
      player.stack += rewardChips;
    }
  }
}

/* --- Unvan (title) tanÄ±mlarÄ± --- */
const TITLE_DEFS = [
  {
    key: "yeni_maceraci",
    name: "ğŸ†• Yeni MaceracÄ±",
    desc: "Oyuna katÄ±ldÄ±n.",
    check: (p) => !!p.joined
  },
  {
    key: "zengin_oyuncu",
    name: "ğŸ’° Zengin Oyuncu",
    desc: "Bakiyen 50.000 Ã§ipi geÃ§ti.",
    check: (p) => p.stack >= 50000
  },
  {
    key: "slot_ustasi",
    name: "ğŸ° Slot UstasÄ±",
    desc: "Slotta toplam +10.000 Ã§ip net kazandÄ±n.",
    check: (p) => (p.stats?.slotNetWin || 0) >= 10000
  },
  {
    key: "rulet_ustasi",
    name: "ğŸ¡ Rulet UstasÄ±",
    desc: "Rulette 10 kez kazandÄ±n.",
    check: (p) => (p.stats?.rouletteWins || 0) >= 10
  },
  {
    key: "bj_efsanesi",
    name: "ğŸƒ Blackjack Efsanesi",
    desc: "Blackjack'te 20 kez kazandÄ±n.",
    check: (p) => (p.stats?.bjWins || 0) >= 20
  },
  {
    key: "sadik_oyuncu",
    name: "ğŸ“… SadÄ±k Oyuncu",
    desc: "7 farklÄ± gÃ¼nde gÃ¼nlÃ¼k Ã¶dÃ¼l aldÄ±n.",
    check: (p) => (p.stats?.dailyDays || 0) >= 7
  },
  {
    key: "yeni_avci",
    name: "ğŸª¶ Yeni AvcÄ±",
    desc: "En az 1 kez .hunt yaptÄ±n.",
    check: (p) => (p.stats?.huntCount || 0) >= 1
  },
  {
    key: "usta_avci",
    name: "ğŸ¦´ Usta AvcÄ±",
    desc: "100 kez .hunt yaptÄ±n.",
    check: (p) => (p.stats?.huntCount || 0) >= 100
  },
  {
    key: "kutu_delisi",
    name: "ğŸ Kutu Delisi",
    desc: "50 kutu aÃ§tÄ±n.",
    check: (p) => (p.stats?.boxesOpened || 0) >= 50
  },
  {
    key: "pet_sahibi",
    name: "ğŸ¾ Pet Sahibi",
    desc: "Ä°lk petini aldÄ±n.",
    check: (p) => !!p.pet
  },
  {
    key: "owo_efsanesi",
    name: "ğŸŒ€ OwO Efsanesi",
    desc: "BirÃ§ok unvan aÃ§tÄ±n.",
    check: (p) => (p.titles?.owned?.length || 0) >= 5
  },
  {
    key: "admin_lord",
    name: "ğŸ‘‘ Sunucu Lordu",
    desc: "YÃ¶neticiye Ã¶zel prestij unvanÄ±.",
    check: (_p) => false // sadece admin komutuyla verilecek
  }
];

function ensureTitles(player) {
  if (!player.titles || typeof player.titles !== "object") {
    player.titles = { owned: [], activeKey: null };
  } else {
    if (!Array.isArray(player.titles.owned)) player.titles.owned = [];
    if (typeof player.titles.activeKey !== "string" && player.titles.activeKey !== null) {
      player.titles.activeKey = null;
    }
  }
}

function getOwnedTitleObjects(player) {
  ensureTitles(player);
  return TITLE_DEFS.filter(def => player.titles.owned.includes(def.key));
}

function getActiveTitleName(player) {
  if (!player.titles || !player.titles.activeKey) return null;
  const def = TITLE_DEFS.find(d => d.key === player.titles.activeKey);
  return def ? def.name : null;
}

async function checkAndUnlockTitles(msg, player) {
  ensureStats(player);
  ensureTitles(player);
  ensurePet(player);
  const newly = [];
  for (const def of TITLE_DEFS) {
    if (def.check(player) && !player.titles.owned.includes(def.key)) {
      player.titles.owned.push(def.key);
      newly.push(def);
    }
  }
  if (newly.length > 0) {
    await saveDB();
    const lines = newly.map(d => `â€¢ ${d.name} â€” ${d.desc}`);
    await msg.reply(
`ğŸ– *Yeni Unvan(lar) KazandÄ±n!*

${lines.join("\n")}

Aktif unvanÄ±nÄ± deÄŸiÅŸtirmek iÃ§in:
.unvan â€” Unvan listesi
.unvan set <numara> â€” Unvan seÃ§`
    );
  }
}

/* ===== OwO tarzÄ± Ã¶ÄŸretici metni ===== */
const OWO_HELP =
`ğŸ¾ *OwO TarzÄ± Oyun Sistemi Nedir?*

Bu bot, Discord'daki OwO botundan esinlenmiÅŸ bir *ekonomi ve mini oyun* sistemidir.
AmaÃ§: Ã§ip biriktirmek, oyunlar oynayÄ±p kazanmak, gÃ¼nlÃ¼k gÃ¶revleri tamamlayÄ±p *unvanlar* ve *petler* toplamaktÄ±r.

ğŸ® *Temel Komutlar*
â€¢ .join â€” Oyuna katÄ±l, baÅŸlangÄ±Ã§ Ã§ipini al
â€¢ .bakiye â€” Bakiyeni ve aktif unvanÄ±nÄ± gÃ¶r
â€¢ .gÃ¼nlÃ¼k â€” GÃ¼nlÃ¼k Ã§ip Ã¶dÃ¼lÃ¼nÃ¼ al
â€¢ .slot <miktar> â€” Slot makinesi oynarsÄ±n
â€¢ .rulet <miktar> <seÃ§im> â€” Rulet oynarsÄ±n (Ã¶rn: .rulet 100 kÄ±rmÄ±zÄ±)
â€¢ .bj <miktar> â€” Blackjack oyunu baÅŸlatÄ±r
â€¢ .hunt â€” Avlan, Ã§ip ve kutu bul (pet bonuslarÄ±yla daha da gÃ¼Ã§lÃ¼)
â€¢ .kutu â€” Elindeki kutularÄ± aÃ§, iÃ§inden Ã§ip Ã§Ä±kar
â€¢ .gÃ¶rev â€” BugÃ¼ne Ã¶zel rastgele 3 gÃ¶revi gÃ¶sterir
â€¢ .unvan â€” Sahip olduÄŸun unvanlarÄ± listele / seÃ§
â€¢ .pet â€” Pet sistemini ve petini gÃ¶ster / .pet al ile pet satÄ±n al
â€¢ .owo â€” Bu rehberi tekrar gÃ¶sterir

ğŸ¾ *Pet Sistemi*
â€¢ .pet al kedi
â€¢ .pet al kopek
â€¢ .pet al ejderha

Her petin kendine ait:
â€¢ ATK: Hunt kazancÄ±nÄ± artÄ±rÄ±r
â€¢ LUCK: Hunt kutu dÃ¼ÅŸme ihtimalini ve kutu Ã¶dÃ¼llerini hafif bufflar

â€¢ .pet â€” Petini ve Ã¶zelliklerini gÃ¶rÃ¼rsÃ¼n
â€¢ .pet isim <yeni_ad> â€” Petine isim verirsin (sadece gÃ¶rÃ¼nÃ¼ÅŸ amaÃ§lÄ±)

ğŸ“œ *GÃ¼nlÃ¼k GÃ¶revler*
â€¢ .gÃ¶rev â€” BugÃ¼ne Ã¶zel rastgele gÃ¶revler:
  - 3 kez slot oyna
  - 2 el blackjack oyna
  - 5 kez .hunt yap
  - 2 kutu aÃ§
  GÃ¶revler tamamlanÄ±nca otomatik Ã§ip Ã¶dÃ¼lÃ¼ eklenir.

ğŸ– *Unvan Sistemi*
â€¢ OynadÄ±kÃ§a sistem seni takip eder ve otomatik unvan aÃ§arsÄ±n:
  - ğŸ†• Yeni MaceracÄ± â†’ Oyuna katÄ±ldÄ±ÄŸÄ±nda
  - ğŸ’° Zengin Oyuncu â†’ 50.000+ Ã§ipin olduÄŸunda
  - ğŸ° Slot UstasÄ± â†’ Slotta Ã§ok kazandÄ±ÄŸÄ±nda
  - ğŸ¡ Rulet UstasÄ± â†’ Rulette defalarca kazandÄ±ÄŸÄ±nda
  - ğŸƒ Blackjack Efsanesi â†’ Blackjack'te ustalaÅŸtÄ±ÄŸÄ±nda
  - ğŸª¶ Yeni AvcÄ± / ğŸ¦´ Usta AvcÄ± â†’ Hunt yaptÄ±kÃ§a
  - ğŸ Kutu Delisi â†’ Bir sÃ¼rÃ¼ kutu aÃ§tÄ±ÄŸÄ±nda
  - ğŸ¾ Pet Sahibi â†’ Ä°lk petini aldÄ±ÄŸÄ±nda
  - ğŸ“… SadÄ±k Oyuncu â†’ FarklÄ± gÃ¼nlerde gÃ¼nlÃ¼k Ã¶dÃ¼l aldÄ±ÄŸÄ±nda

â€¢ .unvan â€” Sahip olduÄŸun unvanlarÄ± listele
â€¢ .unvan set <numara> â€” Aktif olarak gÃ¶stermek istediÄŸin unvanÄ± seÃ§

ğŸ‘‘ *YÃ¶netici Ã–zel*
â€¢ .pet adminkurt â†’ Adminâ€™e Ã¶zel Alfa Kurt peti
â€¢ .unvan admin â†’ Adminâ€™e Ã¶zel Sunucu Lordu unvanÄ±nÄ± aÃ§ar
â€¢ .eventbuff â†’ 15 dk boyunca hunt & kutu kazancÄ±nÄ± arttÄ±ran etkinlik baÅŸlatÄ±r

ğŸ’¡ *Taktik*
Her gÃ¼n:
1) .join (bir kereye mahsus)
2) .gÃ¼nlÃ¼k al
3) .slot / .rulet / .bj / .hunt ile oyna
4) .kutu ile kutularÄ± aÃ§
5) .gÃ¶rev ile gÃ¶revlerini takip et
6) .pet al ile pet sahibi ol, buff kasa
7) .unvan ile havalÄ± unvanÄ±nÄ± seÃ§ ğŸ˜`;

/* ==================== Oyuncu yapÄ±sÄ± ==================== */
function getPlayer(id, name) {
  if (!db.data.players[id]) {
    db.data.players[id] = {
      name,
      stack: STARTING_STACK,
      lastDaily: "",
      locked: false,
      joined: false,
      stats: undefined,
      quests: undefined,
      titles: undefined,
      inv: undefined,
      pet: undefined
    };
  } else {
    const p = db.data.players[id];
    if (name && !p.name) p.name = name;
    if (typeof p.joined !== "boolean") p.joined = false;
    if (typeof p.locked !== "boolean") p.locked = false;
    if (typeof p.stack !== "number") p.stack = STARTING_STACK;
    if (typeof p.lastDaily !== "string") p.lastDaily = "";
  }
  const p = db.data.players[id];
  ensureStats(p);
  ensureQuests(p);
  ensureTitles(p);
  ensureInventory(p);
  ensurePet(p);
  return p;
}

// --- Oyuna katÄ±lÄ±m ÅŸartÄ± kontrolÃ¼ ---
async function requireJoined(msg, player) {
  if (player.joined) return true;
  await msg.reply("ğŸŸ Oyuna katÄ±lmak iÃ§in `.join` yaz.");
  return false;
}

// --- Mesaj sahibine gÃ¶re stabil oyun anahtarÄ± Ã¼retir ---
function makeGameKey(msg, s) {
  const chat = (msg.from || "").split("@")[0];
  const author = (msg.author || "").split("@")[0];
  if (s.phoneId) return `p:${s.phoneId}`;
  if (author)  return `g:${chat}:${author}`;
  return `c:${chat}`;
}

/* ====== LID uyumlu gÃ¶nderen Ã§Ã¶zÃ¼mleyici ====== */
async function resolveSender(msg) {
  const authorId = msg.author || "";
  const fromId   = msg.from   || "";
  const authorUser = authorId.split("@")[0];
  const fromUser   = fromId.split("@")[0];
  const contact = await msg.getContact().catch(() => null);
  let number = null;
  try { number = contact && (await contact.getNumber?.()); } catch {}
  const widUser = contact?.id?.user || null;
  const phoneCandidate = number || widUser || null;
  const lidCandidate   = authorUser || fromUser || null;
  return {
    phoneId: phoneCandidate ? normPhone(phoneCandidate) : null,
    phoneIdLast10: phoneCandidate ? phoneCandidate.replace(/\D/g, "").slice(-10) : null,
    lid: lidCandidate || null
  };
}

/* ====== Tek hedef Ã§Ã¶zÃ¼cÃ¼ (mention > reply > numara > internal) ====== */
const samePerson = (a, b) => last10(a) === last10(b);

async function resolveSingleTarget(msg) {
  const foundMentions = [];
  const foundReply = [];
  const foundNumbers = [];
  const foundInternal = [];

  // A) Mentions
  try {
    const mentions = (await msg.getMentions?.()) || [];
    for (const c of mentions) {
      let n = null;
      try { n = await c.getNumber?.(); } catch {}
      const u = c?.id?.user || null;
      const cand = n || u;
      if (cand) {
        const pn = normPhone(cand);
        if (!foundMentions.some(x => samePerson(x, pn))) foundMentions.push(pn);
      }
    }
  } catch {}

  // B) Reply owner
  try {
    const quoted = await msg.getQuotedMessage?.();
    if (quoted) {
      const qc = await quoted.getContact?.();
      let qn = null;
      try { qn = await qc.getNumber?.(); } catch {}
      const qu = qc?.id?.user || null;
      const cand = qn || qu;
      if (cand) {
        const pn = normPhone(cand);
        if (!foundReply.some(x => samePerson(x, pn))) foundReply.push(pn);
      }
    }
  } catch {}

  // C) Plain numbers in text
  const words = (msg.body || "").split(/\s+/);
  for (const w of words) {
    const d = (w || "").replace(/\D/g, "");
    if (d.length >= 10 && d.length <= 15) {
      const pn = normPhone(d);
      if (!foundNumbers.some(x => samePerson(x, pn))) foundNumbers.push(pn);
    }
  }

  // D) Internal mentionedIds
  try {
    const raw = msg?._data?.mentionedIds || msg?.mentionedIds || [];
    for (const r of raw) {
      const u = String(r).split("@")[0];
      if (u) {
        const pn = normPhone(u);
        if (!foundInternal.some(x => samePerson(x, pn))) foundInternal.push(pn);
      }
    }
  } catch {}

  const pickUnique = (arr) => {
    const out = [];
    for (const p of arr) if (!out.some(x => samePerson(x, p))) out.push(p);
    return out;
  };

  const m = pickUnique(foundMentions);
  if (m.length === 1) return { ok: true, id: m[0] };
  if (m.length > 1) return { ok: false, reason: "multi", message: `âš ï¸ Birden fazla kiÅŸi algÄ±landÄ± (${m.map(x => last10(x)).join(", ")}). LÃ¼tfen *tek* bir kiÅŸi belirt.` };

  const r = pickUnique(foundReply);
  if (r.length === 1) return { ok: true, id: r[0] };
  if (r.length > 1) return { ok: false, reason: "multi", message: `âš ï¸ Birden fazla kiÅŸi algÄ±landÄ± (${r.map(x => last10(x)).join(", ")}). LÃ¼tfen *tek* bir kiÅŸi belirt.` };

  const n = pickUnique(foundNumbers);
  if (n.length === 1) return { ok: true, id: n[0] };
  if (n.length > 1) return { ok: false, reason: "multi", message: `âš ï¸ Birden fazla kiÅŸi algÄ±landÄ± (${n.map(x => last10(x)).join(", ")}). LÃ¼tfen *tek* bir kiÅŸi belirt.` };

  const i = pickUnique(foundInternal);
  if (i.length === 1) return { ok: true, id: i[0] };
  if (i.length > 1) return { ok: false, reason: "multi", message: `âš ï¸ Birden fazla kiÅŸi algÄ±landÄ± (${i.map(x => last10(x)).join(", ")}). LÃ¼tfen *tek* bir kiÅŸi belirt.` };

  return {
    ok: false,
    reason: "none",
    message: "âš ï¸ Hedef bulunamadÄ±. *Tek* bir @kiÅŸi etiketle, numarasÄ±nÄ± yaz ya da kiÅŸinin mesajÄ±nÄ± *yanÄ±tlayarak* gÃ¶nder."
  };
}

/* ====== Mentionâ€™lardan toplu Ã§Ä±karÄ±cÄ± (bazÄ± admin komutlarÄ± iÃ§in) ====== */
function onlyDigits(s){ return (s||"").replace(/\D/g,""); }
async function extractMentionedIds(msg) {
  try {
    const contacts = (await msg.getMentions?.()) || [];
    const fromMentions = await Promise.all(contacts.map(async (c) => {
      let n = null;
      try { n = await c.getNumber?.(); } catch {}
      const u = c?.id?.user || null;
      const cand = n || u;
      return cand ? normPhone(cand) : null;
    }));
    const mentionIds = fromMentions.filter(Boolean);
    const raw = (msg.body || "")
      .split(/\s+/)
      .filter(w => /^\d{10,15}$/.test(onlyDigits(w)))
      .map(w => normPhone(w));
    return Array.from(new Set([...mentionIds, ...raw]));
  } catch {
    return [];
  }
}

/* ==================== Dedupe (aynÄ± mesajÄ± 2 kez iÅŸlemeyi engelle) ==================== */
const SEEN = new Set();
function shouldProcess(msg) {
  const key = msg?.id?._serialized || msg?.id?.id || `${msg.timestamp}:${msg.from}`;
  if (SEEN.has(key)) return false;
  SEEN.add(key);
  setTimeout(() => SEEN.delete(key), 60_000);
  return true;
}

/* ==== Transfer dedupe (aynÄ± mesajdan 2. kez para Ã§Ä±kmasÄ±n) ==== */
const DONE_TX = new Set();

/* ==================== Oyun Durumu & YardÄ±mcÄ±lar ==================== */
const animations = ["ğŸ‚ ğŸ’«", "ğŸƒâœ¨", "ğŸ’¥ğŸ‚¡", "ğŸ´ğŸŒ€", "ğŸ’«ğŸ‚±", "ğŸª„ğŸ‚¾", "ğŸ’¨ğŸƒ", "ğŸ‚«ğŸ”¥"];
const games = {};

const suits = ["â™ ï¸", "â™¥ï¸", "â™¦ï¸", "â™£ï¸"];
const values = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];
function drawCard() {
  const suit = suits[Math.floor(Math.random() * suits.length)];
  const value = values[Math.floor(Math.random() * values.length)];
  return { suit, value };
}
function getHandValue(hand) {
  let value = 0, aces = 0;
  for (const card of hand) {
    if (["J", "Q", "K"].includes(card.value)) value += 10;
    else if (card.value === "A") { value += 11; aces++; }
    else value += parseInt(card.value, 10);
  }
  while (value > 21 && aces > 0) { value -= 10; aces--; }
  return value;
}

// --- GÃ¶rÃ¼nÃ¼m YardÄ±mcÄ±larÄ± ---
function suitDot(suit) { return (suit === "â™¥ï¸" || suit === "â™¦ï¸") ? "ğŸ”´" : "âš«"; }
function handToDotString(hand) { return hand.map(c => `${c.value}${suitDot(c.suit)}`).join(" "); }
function valueText(val) { return (val > 21) ? "BUST! ğŸ’¥" : String(val); }

/* --- Eski string kalabilir (slot/diagnostic iÃ§in) --- */
function handToString(hand) { return hand.map(c => `${c.value}${c.suit}`).join(" "); }

/* ===== Grup yardÄ±mcÄ±larÄ± (admin kontrolÃ¼) ===== */
async function isGroupAdminByMsg(msg) {
  const chat = await msg.getChat();
  if (!chat.isGroup) return { isGroup: false, isGroupAdmin: false, chat };
  const senderId = msg.author || (await msg.getContact())?.id?._serialized;
  const isGroupAdmin = (chat.participants || []).some(p =>
    p.isAdmin && (p.id?._serialized === senderId)
  );
  return { isGroup: true, isGroupAdmin, chat };
}

/* ========== YardÄ±m metni (admin'e gÃ¶re dinamik) ========== */
function buildHelpText(isAdmin) {
  const userPart =
`â™£ï¸ *Komutlar*
â€¢ .join â€” Oyuna katÄ±l
â€¢ .bakiye â€” Bakiyeni gÃ¶sterir
â€¢ .gÃ¼nlÃ¼k â€” GÃ¼nlÃ¼k Ã¶dÃ¼l
â€¢ .score â€” Skor tablosu
â€¢ .slot <miktar> â€” Slot
â€¢ .bj <miktar> | .bj bet <miktar> â€” Blackjack
â€¢ .rulet <miktar> <seÃ§im> â€” Rulet (Ã¶rn: .rulet 100 kÄ±rmÄ±zÄ±)
â€¢ .hunt â€” Avlan, Ã§ip ve kutu kazan
â€¢ .kutu â€” Elindeki kutularÄ± aÃ§
â€¢ .gÃ¶rev â€” GÃ¼nlÃ¼k rastgele gÃ¶revlerini gÃ¶sterir
â€¢ .unvan â€” UnvanlarÄ±nÄ± listele / ayarla
â€¢ .pet â€” Petini gÃ¶r, .pet al ile pet satÄ±n al
â€¢ .owo â€” OwO tarzÄ± sistemi anlatan rehber

ğŸ® Oyun iÃ§i: .hit | .stand | .db | .sur

â„¹ï¸ Ä°pucu: ".bj" tek baÅŸÄ±na yazÄ±nca kÄ±sayol menÃ¼sÃ¼ gelir. ".rulet" tek baÅŸÄ±na yazÄ±nca rulet yardÄ±mÄ±nÄ± gÃ¶rÃ¼rsÃ¼n.`;

  const adminPart =
`\n\nğŸ‘‘ *YÃ¶netici KomutlarÄ±*
â€¢ .allpman â€” Herkese +5000
â€¢ .alpman â€” Kendine +15000
â€¢ .max â€” Kendine 999999999999 Ã§ip ekler
â€¢ .listedenat @kiÅŸi â€” Skordan Ã§Ä±kar
â€¢ .bakiye reset @kiÅŸi â€” 0 yap
â€¢ .send <miktar> @kiÅŸi â€” Ã‡ip gÃ¶nder
â€¢ !everyone [mesaj] â€” Gruptaki herkesi etiketle
â€¢ !kilit â€” Sadece yÃ¶neticiler mesaj atabilsin
â€¢ !kilitaÃ§ â€” Herkese tekrar yazma izni
â€¢ .pet adminkurt â€” Adminâ€™e Ã¶zel Alfa Kurt peti verir
â€¢ .unvan admin â€” Adminâ€™e Ã¶zel Sunucu Lordu unvanÄ±nÄ± aÃ§ar
â€¢ .eventbuff â€” Hunt & kutu iÃ§in geÃ§ici etkinlik buffâ€™Ä± baÅŸlatÄ±r`;

  return isAdmin ? (userPart + adminPart) : userPart;
}

/* ==================== SLOT & JACKPOT ==================== */
const symbols = ["ğŸ’", "ğŸ‹", "ğŸ‰", "ğŸ‡", "ğŸ¥", "ğŸ€", "â­"];
const paytable = { "ğŸ’": 2, "ğŸ‹": 3, "ğŸ‰": 4, "ğŸ‡": 5, "ğŸ¥": 6, "ğŸ€": 8, "â­": 12 };
let jackpot = 5000;
function spinSlot() {
  const grid = Array.from({ length: 3 }, () =>
    Array.from({ length: 3 }, () => symbols[Math.floor(Math.random() * symbols.length)])
  );
  return grid;
}
function checkSlotWin(grid, bet) {
  let totalWin = 0;
  const lines = [];
  for (let r = 0; r < 3; r++) {
    if (grid[r][0] === grid[r][1] && grid[r][1] === grid[r][2]) {
      const sym = grid[r][0];
      const win = bet * paytable[sym];
      totalWin += win;
      lines.push(`â­ SatÄ±r ${r + 1}: ${sym}${sym}${sym} â†’ +${win}`);
      if (sym === "â­") {
        totalWin += jackpot;
        lines.push(`ğŸ’¥ğŸ’° JACKPOT! +${jackpot} Ã‡ip!`);
        jackpot = 5000;
      }
    }
  }
  if (totalWin === 0) jackpot += Math.floor(bet * 0.2);
  return { totalWin, lines };
}

/* ==================== RULET ==================== */
/* Ã–ÄŸretici metin */
const ROULET_HELP = 
`ğŸ¡ *RULET Ã–ÄRETÄ°CÄ°SÄ°* ğŸ¡

Rulet oynamak iÃ§in komut:
.rulet <miktar> <seÃ§im>

ğŸ”¢ 1) Miktar Nedir?
â€¢ Oyun iÃ§in kaÃ§ Ã§iple bahis yapacaÄŸÄ±nÄ± gÃ¶sterir.
â€¢ Ã–rnek: 100, 250, 1000...

ğŸ¯ 2) SeÃ§im Nedir?
ParanÄ± neye oynadÄ±ÄŸÄ±nÄ± gÃ¶sterir. Bu bottaki geÃ§erli seÃ§imler:

ğŸ¨ Renk Bahisleri (1:1 Ã¶deme)
â€¢ kÄ±rmÄ±zÄ±  â†’ "kÄ±rmÄ±zÄ±", "k", "red"
â€¢ siyah    â†’ "siyah", "s", "black"

ğŸ”¢ Tek / Ã‡ift (1:1 Ã¶deme)
â€¢ tek   â†’ "tek", "odd"
â€¢ Ã§ift  â†’ "cift", "cif", "even"

ğŸ“‰ DÃ¼ÅŸÃ¼k / YÃ¼ksek (1:1 Ã¶deme)
â€¢ 1-18  â†’ "1-18", "alt", "low"
â€¢ 19-36 â†’ "19-36", "ust", "yuksek", "high"

ğŸ“¦ DÃ¼zineler (2:1 Ã¶deme)
â€¢ 1-12   â†’ "1-12", "d1", "duzin1", "duzine1"
â€¢ 13-24  â†’ "13-24", "d2", "duzin2", "duzine2"
â€¢ 25-36  â†’ "25-36", "d3", "duzin3", "duzine3"

ğŸ¯ Tek SayÄ± (0â€“36) (35:1 Ã¶deme)
â€¢ DoÄŸrudan bir sayÄ± yazabilirsin:
  Ã–rn: 0, 7, 17, 32...

ğŸ’° 3) Ã–deme OranlarÄ±
â€¢ Renk / Tek / Ã‡ift / 1-18 / 19-36 â†’ 1:1
â€¢ DÃ¼zineler â†’ 2:1
â€¢ Tek sayÄ± â†’ 35:1

ğŸ“Œ Ã–rnek KullanÄ±mlar
â€¢ .rulet 100 kÄ±rmÄ±zÄ±
â€¢ .rulet 200 tek
â€¢ .rulet 150 1-12
â€¢ .rulet 50 17
â€¢ .rulet 100 0

ğŸ® Oyuna baÅŸlamak iÃ§in:
.rulet 100 kÄ±rmÄ±zÄ± yaz!

â„¹ï¸ Not:
â€¢ Ã–nce oyuna katÄ±lmak iÃ§in .join yaz.
â€¢ Bakiyeni gÃ¶rmek iÃ§in: .bakiye
â€¢ Minimum bahis sistemde ayarlÄ±dÄ±r.`;

/* Avrupa ruleti (0â€“36) */
const REDS = new Set([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]);
function rouletteColor(n) {
  if (n === 0) return { name: "yeÅŸil", dot: "ğŸŸ¢" };
  if (REDS.has(n)) return { name: "kÄ±rmÄ±zÄ±", dot: "ğŸ”´" };
  return { name: "siyah", dot: "âš«" };
}
function rouletteSpin() {
  return Math.floor(Math.random() * 37); // 0..36
}
function normalizeTR(s){
  return (s||"")
    .toLowerCase()
    .replace(/Ä±/g,"i")
    .replace(/ÅŸ/g,"s")
    .replace(/Ã§/g,"c")
    .replace(/Ã¶/g,"o")
    .replace(/Ã¼/g,"u")
    .replace(/ÄŸ/g,"g")
    .trim();
}
/**
 * Parse pick string(s) => { ok, kind, title, test(n), payout }
 * payout: multiplier (Ã¶r: 1 = 1:1, 2 = 2:1, 35 = 35:1)
 */
function parseRoulettePick(rawTokens){
  const raw = normalizeTR(rawTokens.join(" "));
  if (!raw) return { ok:false, message: "KullanÄ±m: .rulet <miktar> <secim>. Ã–rn: .rulet 100 kirmizi" };

  const t = raw;

  // SayÄ± (0-36)
  const num = parseInt(t, 10);
  if (Number.isFinite(num) && num >= 0 && num <= 36) {
    return {
      ok: true, kind: "number", title: `SayÄ± ${num}`,
      test: (n)=> n === num, payout: 35
    };
  }

  // Renk
  if (["k","kirmizi","red"].includes(t)) {
    return { ok:true, kind:"color:red", title:"KÄ±rmÄ±zÄ±", test:(n)=> n!==0 && REDS.has(n), payout:1 };
  }
  if (["s","siyah","black"].includes(t)) {
    return { ok:true, kind:"color:black", title:"Siyah", test:(n)=> n!==0 && !REDS.has(n), payout:1 };
  }

  // Tek / Ã‡ift
  if (["tek","odd"].includes(t)) {
    return { ok:true, kind:"odd", title:"Tek", test:(n)=> n!==0 && n%2===1, payout:1 };
  }
  if (["cift","cif","even"].includes(t)) {
    return { ok:true, kind:"even", title:"Ã‡ift", test:(n)=> n!==0 && n%2===0, payout:1 };
  }

  // 1-18 / 19-36
  if (["1-18","alt","low"].includes(t)) {
    return { ok:true, kind:"low", title:"1-18", test:(n)=> n>=1 && n<=18, payout:1 };
  }
  if (["19-36","ust","ust-","high","yuksek"].includes(t)) {
    return { ok:true, kind:"high", title:"19-36", test:(n)=> n>=19 && n<=36, payout:1 };
  }

  // DÃ¼zineler
  if (["1-12","d1","duzin1","duzine1"].includes(t)) {
    return { ok:true, kind:"dozen1", title:"1-12", test:(n)=> n>=1 && n<=12, payout:2 };
  }
  if (["13-24","d2","duzin2","duzine2"].includes(t)) {
    return { ok:true, kind:"dozen2", title:"13-24", test:(n)=> n>=13 && n<=24, payout:2 };
  }
  if (["25-36","d3","duzin3","duzine3"].includes(t)) {
    return { ok:true, kind:"dozen3", title:"25-36", test:(n)=> n>=25 && n<=36, payout:2 };
  }

  return { ok:false, message:
`âš ï¸ GeÃ§ersiz seÃ§im.
Ã–rnekler:
â€¢ .rulet 100 kÄ±rmÄ±zÄ±
â€¢ .rulet 200 tek
â€¢ .rulet 150 1-12
â€¢ .rulet 50 17
â€¢ .rulet 100 0` };
}

/* ==================== WhatsApp Client ==================== */
const client = new Client({
  authStrategy: new LocalAuth(),
  puppeteer: { headless: true, args: ["--no-sandbox", "--disable-setuid-sandbox", "--disable-dev-shm-usage"] }
});

client.on("qr", qr => qrcode.generate(qr, { small: true }));
client.on("ready", () => console.log("âœ… Bot aktif!"));
client.on("auth_failure", m => console.error("âŒ Kimlik doÄŸrulama hatasÄ±:", m));
client.on("disconnected", r => console.warn("âš ï¸ BaÄŸlantÄ± koptu:", r));

/* ==================== Ortak: Admin kontrol ==================== */
function isAdminCheck(sender) {
  const fileAdmins = readAdmins();
  const phonePool = [
    ...ADMIN_PHONES,
    ...(fileAdmins.phones || []).map(normPhone)
  ];
  if (sender.phoneId) {
    const p = sender.phoneId;
    const p10 = sender.phoneIdLast10;
    if (phonePool.some(ap => ap === p || last10(ap) === p10)) return true;
  }
  if (sender.lid) {
    if ((fileAdmins.lids || []).includes(sender.lid)) return true;
  }
  return false;
}

/* ==================== Mesaj Ä°ÅŸleyici ==================== */
async function handleMessageSafe(msg) {
  if (!shouldProcess(msg)) return;

  try {
    const s = await resolveSender(msg);
    const isAdmin = isAdminCheck(s);
    const contact = await msg.getContact().catch(() => null);
    const name = contact?.pushname || contact?.name || msg._data?.notifyName || (s.phoneId || s.lid || "unknown");

    const keyId = s.phoneId || s.lid || (msg.author || msg.from);
    const player = getPlayer(keyId, name);

    /* === GÃœNCEL: GÃ¼nlÃ¼k Ã¶dÃ¼l (otomatik, ilk mesajda) === */
    try {
      if (player.joined) {
        const todayKey = localDateKey();
        if (player.lastDaily !== todayKey) {
          player.lastDaily = todayKey;
          player.stack += DAILY_REWARD;
          ensureStats(player);
          player.stats.dailyDays = (player.stats.dailyDays || 0) + 1;
          applyQuestProgress(player, "dailyClaim", 1);
          await saveDB();
          try {
            await msg.reply(`ğŸ *GÃ¼nlÃ¼k Ã¶dÃ¼l (otomatik):* +${DAILY_REWARD}\nğŸ¦ Bakiye: ${player.stack}`);
          } catch {}
          await checkAndUnlockTitles(msg, player);
        }
      }
    } catch {}

    /* Otomatik destek */
    if (player.stack <= 0) {
      player.stack = AUTO_TOPUP;
      await saveDB();
      try { await msg.reply(`ğŸ†“ Otomatik destek: +${AUTO_TOPUP} Ã§ip yÃ¼klendi. Bol ÅŸans!`); } catch {}
    }

    const keyGame = makeGameKey(msg, s);

    const body = (msg.body || "").trim();
    const args = body.split(/\s+/);
    const base = args[0]?.toLowerCase();

    // Ping & TeÅŸhis
    if (body.toLowerCase() === "ping") { await msg.reply("pong"); return; }
    if (base === ".me") {
      return msg.reply(
        `name: ${player.name || "-"}\n` +
        `joined: ${player.joined}\n` +
        `keyId(DB): ${keyId}\nkeyGame(GAME): ${keyGame}\n` +
        `phoneId: ${s.phoneId || "-"} / last10: ${s.phoneIdLast10 || "-"}\n` +
        `lid: ${s.lid || "-"}\n` +
        `isAdmin: ${isAdmin}`
      );
    }
    if (base === ".state") {
      const g = games[keyGame];
      return msg.reply(g ? `Game var: bet=${g.bet} | P=[${g.playerHand?.length||0}] D=[${g.dealerHand?.length||0}]` : "Game yok.");
    }

    /* OwO Ã¶ÄŸretici */
    if (base === ".owo") {
      return msg.reply(OWO_HELP);
    }

    /* ==================== EVENT BUFF (.eventbuff) ==================== */
    if (base === ".eventbuff" || base === ".etkinlik") {
      if (!isAdmin) return msg.reply("ğŸš« Bu komut iÃ§in yetkin yok.");
      const sub = (args[1] || "").toLowerCase();

      if (sub === "off" || sub === "kapat" || sub === "bitir" || sub === "stop") {
        eventBuff.active = false;
        eventBuff.until = 0;
        return msg.reply("âš¡ Etkinlik buff'Ä± manuel olarak kapatÄ±ldÄ±.");
      }

      if (isEventBuffActive()) {
        return msg.reply(`âš¡ Zaten bir etkinlik buff'Ä± aÃ§Ä±k.\nKalan sÃ¼re: ${eventBuffRemainingText()}\nKapatmak iÃ§in: .eventbuff off`);
      }

      const DURATION_MIN = 15;
      eventBuff.active = true;
      eventBuff.until = Date.now() + DURATION_MIN * 60 * 1000;

      return msg.reply(
`âš¡ *Etkinlik BaÅŸladÄ±!*

Ã–nÃ¼mÃ¼zdeki ${DURATION_MIN} dakika boyunca:
â€¢ .hunt kazanÃ§larÄ± arttÄ±
â€¢ .kutu Ã¶dÃ¼lleri buff aldÄ±

Mevcut durum: ${eventBuffRemainingText()}
Kapatmak iÃ§in: .eventbuff off`
      );
    }

    /* ==================== PET SÄ°STEMÄ° (.pet) ==================== */
    if (base === ".pet") {
      if (!(await requireJoined(msg, player))) return;
      ensurePet(player);

      const sub = (args[1] || "").toLowerCase();

      // pet durumu
      if (!sub) {
        if (!player.pet) {
          const shopLines = Object.values(PET_SHOP).map(p =>
            `${p.emoji} *${p.label}* â€” Fiyat: ${p.price} Ã§ip\n   ATK: ${p.atk} | LUCK: ${p.luck}\n   ${p.desc}`
          ).join("\n\n");
          const adminLine = isAdmin
            ? `\n\nğŸ‘‘ Adminâ€™e Ã¶zel pet iÃ§in:\nâ€¢ .pet adminkurt`
            : "";
          return msg.reply(
`ğŸ¾ *Pet Sistemi*

Åu an bir petin yok.

Pet alarak:
â€¢ .hunt kazancÄ±na (ATK) bonus alÄ±rsÄ±n
â€¢ Kutularda ve hunt kutu dÃ¼ÅŸme ÅŸansÄ±nda (LUCK) kÃ¼Ã§Ã¼k buff kazanÄ±rsÄ±n

ğŸ“¦ *Pet Shop*
${shopLines}${adminLine}

Pet almak iÃ§in:
.pet al <tÃ¼r>
Ã–rn:
â€¢ .pet al kedi
â€¢ .pet al kopek
â€¢ .pet al ejderha`
          );
        } else {
          const pet = player.pet;
          const cfg = pet.type && PET_SHOP[pet.type] ? PET_SHOP[pet.type] : null;
          const emoji = cfg?.emoji || (pet.type === ADMIN_PET.key ? ADMIN_PET.emoji : "ğŸ¾");
          const label = cfg?.label || (pet.type === ADMIN_PET.key ? ADMIN_PET.label : (pet.type || "Bilinmeyen tÃ¼r"));
          const nameLine = pet.name ? `${pet.name} (${label})` : label;
          return msg.reply(
`${emoji} *Pet Bilgilerin*

AdÄ±: ${nameLine}
TÃ¼r: ${pet.type || "-"}
Seviye: ${pet.level || 1}
XP: ${pet.xp || 0}
ATK: ${pet.atk || 0}
LUCK: ${pet.luck || 0}

Etkileri:
â€¢ .hunt kazancÄ±na ATK kadar bonus ekler (kÃ¼Ã§Ã¼k bir Ã§arpan)
â€¢ Hunt sÄ±rasÄ±nda kutu dÃ¼ÅŸme ÅŸansÄ±nÄ± LUCK ile arttÄ±rÄ±r
â€¢ Kutu aÃ§arken Ã¶dÃ¼le ufak ekstra Ã§ip ekleyebilir

Ä°sim deÄŸiÅŸtirmek iÃ§in:
.pet isim <yeni_isim>`
          );
        }
      }

      // ADMIN PET: .pet adminkurt
      if (sub === "adminkurt" || sub === "adminpet" || sub === "admin") {
        if (!isAdmin) {
          return msg.reply("ğŸš« Bu pet sadece yÃ¶neticiler iÃ§indir.");
        }
        player.pet = {
          type: ADMIN_PET.key,
          name: ADMIN_PET.label,
          level: 1,
          xp: 0,
          atk: ADMIN_PET.atk,
          luck: ADMIN_PET.luck
        };
        await saveDB();
        await checkAndUnlockTitles(msg, player);

        return msg.reply(
`${ADMIN_PET.emoji} *Admin Peti Verildi!*

ArtÄ±k *${ADMIN_PET.label}* senin yanÄ±nda:
ATK: ${ADMIN_PET.atk}
LUCK: ${ADMIN_PET.luck}

Bu peti sadece adminler alabilir.
ğŸ¦ Bakiye deÄŸiÅŸmedi: ${player.stack}`
        );
      }

      // pet satÄ±n alma
      if (sub === "al" || sub === "buy") {
        const rawType = args[2];
        if (!rawType) {
          return msg.reply(
`KullanÄ±m: .pet al <tÃ¼r>

Mevcut tÃ¼rler:
â€¢ kedi
â€¢ kopek
â€¢ ejderha

Ã–rnek:
â€¢ .pet al kedi`
          );
        }
        const typeKey = petTypeFromInput(rawType);
        if (!typeKey || !PET_SHOP[typeKey]) {
          return msg.reply(
`âš ï¸ GeÃ§ersiz pet tÃ¼rÃ¼.

KullanÄ±m:
â€¢ .pet al kedi
â€¢ .pet al kopek
â€¢ .pet al ejderha`
          );
        }
        const cfg = PET_SHOP[typeKey];
        if (player.stack < cfg.price) {
          return msg.reply(`ğŸš« Yetersiz bakiye. Gerekli: ${cfg.price}, Senin: ${player.stack}`);
        }

        player.stack -= cfg.price;
        player.pet = {
          type: cfg.key,
          name: cfg.label,
          level: 1,
          xp: 0,
          atk: cfg.atk,
          luck: cfg.luck
        };

        await saveDB();
        await checkAndUnlockTitles(msg, player);

        return msg.reply(
`${cfg.emoji} *Pet SatÄ±n AlÄ±ndÄ±!*

ArtÄ±k bir petin var:
AdÄ±: ${cfg.label}
TÃ¼r: ${cfg.label}
ATK: ${cfg.atk}
LUCK: ${cfg.luck}

Petin:
â€¢ .hunt kazancÄ±nÄ± artÄ±rÄ±r
â€¢ Kutulardaki Ã¶dÃ¼le ufak bonus ekler

Ä°sim vermek iÃ§in:
.pet isim <yeni_isim>

ğŸ¦ Kalan Bakiye: ${player.stack}`
        );
      }

      // pet isim deÄŸiÅŸtirme
      if (sub === "isim" || sub === "name") {
        if (!player.pet) {
          return msg.reply("Åu an bir petin yok. Ã–nce `.pet al <tÃ¼r>` veya admin isen `.pet adminkurt` ile pet al.");
        }
        const newName = args.slice(2).join(" ").trim();
        if (!newName) {
          return msg.reply("KullanÄ±m: `.pet isim <yeni_isim>`");
        }
        if (newName.length > 24) {
          return msg.reply("âš ï¸ Ä°sim Ã§ok uzun. Maksimum 24 karakter kullan.");
        }
        player.pet.name = newName;
        await saveDB();
        return msg.reply(`ğŸ¾ Petinin yeni adÄ±: *${newName}*`);
      }

      // bilinmeyen alt komutlar
      return msg.reply(
`ğŸ¾ Pet komutlarÄ±:
â€¢ .pet â€” Pet durumunu gÃ¶ster
â€¢ .pet al <tÃ¼r> â€” Pet satÄ±n al (kedi / kopek / ejderha)
â€¢ .pet adminkurt â€” (Sadece admin) Ã¶zel Alfa Kurt peti
â€¢ .pet isim <yeni_isim> â€” Petine isim ver`
      );
    }

    /* ==================== GRUP YÃ–NETÄ°M KOMUTLARI ==================== */
    if (base === "!everyone" || base === "!kilit" || base === "!kilitaÃ§" || base === "!kilitac") {
      const { isGroup, isGroupAdmin, chat } = await isGroupAdminByMsg(msg);
      if (!isGroup) return msg.reply("â„¹ï¸ Bu komut sadece *gruplarda* kullanÄ±labilir.");

      const canModerate = isAdmin || isGroupAdmin;
      if ((base === "!kilit" || base === "!kilitaÃ§" || base === "!kilitac") && !canModerate) {
        return msg.reply("ğŸš« Bu komut iÃ§in grup yÃ¶neticisi olmalÄ±sÄ±n (ya da bot admini).");
      }

      if (base === "!everyone") {
        try {
          const participants = chat.participants || [];
          if (!participants.length) return msg.reply("âš ï¸ Grup katÄ±lÄ±mcÄ±larÄ± alÄ±namadÄ±.");
          const mentionContacts = await Promise.all(
            participants.map(p => client.getContactById(p.id._serialized))
          );
          const tagLine = participants.map(p => `@${p.id.user}`).join(" ");
          const extra = args.slice(1).join(" ").trim();
          const text = (extra ? `${extra}\n` : "") + tagLine;
          await chat.sendMessage(text, { mentions: mentionContacts });
        } catch (e) {
          console.error("!everyone hatasÄ±:", e);
          await msg.reply("âš ï¸ everyone gÃ¶nderilemedi.");
        }
        return;
      }

      if (base === "!kilit") {
        try {
          await chat.setMessagesAdminsOnly(true);
          await msg.reply("ğŸ”’ Grup *sadece yÃ¶neticilere* kilitlendi.");
        } catch (e) {
          console.error("!kilit hatasÄ±:", e);
          await msg.reply("âš ï¸ Kilitlenemedi. Botun *grup yÃ¶neticisi* olmasÄ± gerekebilir.");
        }
        return;
      }

      if (base === "!kilitaÃ§" || base === "!kilitac") {
        try {
          await chat.setMessagesAdminsOnly(false);
          await msg.reply("ğŸ”“ Grup yeniden *herkese* aÃ§Ä±ldÄ±.");
        } catch (e) {
          console.error("!kilitaÃ§ hatasÄ±:", e);
          await msg.reply("âš ï¸ Kilit aÃ§Ä±lamadÄ±. Botun *grup yÃ¶neticisi* olmasÄ± gerekebilir.");
        }
        return;
      }
    }

    /* ==================== KATILIM: .join ==================== */
    if (base === ".join") {
      if (player.joined) {
        const activeTitleName = getActiveTitleName(player);
        const titleLine = activeTitleName ? `\nğŸ– Unvan: ${activeTitleName}` : "";
        return msg.reply(`âœ… Zaten katÄ±ldÄ±n.\nğŸ¦ Bakiye: ${player.stack}${titleLine}`);
      }
      player.joined = true;
      await saveDB();
      await checkAndUnlockTitles(msg, player);
      return msg.reply(
`ğŸŸ *Oyuna katÄ±ldÄ±n!*
HoÅŸ geldin ${player.name || ""} ğŸ‰
ğŸ¦ BaÅŸlangÄ±Ã§ bakiyen: ${player.stack}
Skor tablosunda gÃ¶rÃ¼nÃ¼rsÃ¼n. Bol ÅŸans!`
      );
    }

    /* ==================== YardÄ±m ==================== */
    if (
      base === ".yardÄ±m" || base === ".yardim" ||
      (base === ".bj" && ["yardÄ±m","yardim","help","menu","menÃ¼"].includes((args[1]||"").toLowerCase()))
    ) {
      return msg.reply(buildHelpText(isAdmin));
    }

    /* ---------- BAKÄ°YE RESET ---------- */
    if (base === ".bakiye" && (args[1]||"").toLowerCase() === "reset") {
      if (!isAdmin) return msg.reply("ğŸš« Bu komut iÃ§in yetkin yok.");
      const tgt = await resolveSingleTarget(msg);
      if (!tgt.ok) return msg.reply(tgt.message);
      const tid = tgt.id;
      const tp = getPlayer(tid, db.data.players[tid]?.name || tid);
      tp.stack = 0;
      await saveDB();
      return msg.reply(`ğŸ§° ${tp.name || tid} iÃ§in bakiye *0* yapÄ±ldÄ±.`);
    }

    /* ---------- BAKÄ°YE GÃ–STER ---------- */
    if ((base === ".bakiye" && args.length === 1) ||
        (base === ".bj" && ["bakiye","balance"].includes((args[1]||"").toLowerCase()) && args.length === 2)) {
      const activeTitleName = getActiveTitleName(player);
      const titleLine = activeTitleName ? `\nğŸ– Unvan: ${activeTitleName}` : "";
      return msg.reply(
        `ğŸ¦ *Bakiye:* ${player.stack} Ã§ip${player.locked ? " (ğŸ”’ kilitli)" : ""}` +
        titleLine +
        `${player.joined ? "" : "\nâ„¹ï¸ Skor tablosuna girmek iÃ§in \`.join\` yaz."}`
      );
    }

    // .score
    if (base === ".score" || base === ".skor" || base === ".scores" || base === ".lb" ||
       (base === ".bj" && ["skor","score","scores","leaderboard","lb"].includes((args[1]||"").toLowerCase()))) {
      const items = Object.entries(db.data.players)
        .map(([pid, p]) => ({ id: pid, name: p.name || pid, stack: p.stack, joined: !!p.joined }))
        .filter(p => p.joined)
        .sort((a,b) => b.stack - a.stack)
        .slice(0, 10);
      const lines = items.map((p, i) => `${i+1}. ${p.name} â€” ${p.stack}`);
      return msg.reply(`ğŸ“œ *Skor Tablosu (KatÄ±lanlar - Top 10)*\n` + (lines.length ? lines.join("\n") : "â€” HenÃ¼z kimse katÄ±lmadÄ±. `.join` yaz!"));
    }

    /* ---------- GÃ–REV SÄ°STEMÄ° ---------- */
    if (base === ".gÃ¶rev" || base === ".gorev" || base === ".quest") {
      if (!(await requireJoined(msg, player))) return;
      ensureQuests(player);
      const qState = player.quests;
      const activeKeys = qState.activeKeys || [];

      if (!activeKeys.length) {
        return msg.reply("BugÃ¼n iÃ§in gÃ¶rev bulunamadÄ±, lÃ¼tfen tekrar deneyin.");
      }

      const lines = activeKeys.map((key, i) => {
        const def = QUEST_POOL.find(q => q.key === key);
        if (!def) return `${i + 1}. (Bilinmeyen gÃ¶rev)`;
        const prog = qState.progress[key] || 0;
        const done = !!qState.completed[key];
        const status = done ? "âœ… TamamlandÄ±" : `â³ ${prog}/${def.target}`;
        const rewardChips = def.reward?.chips || 0;
        const rewardText = rewardChips > 0 ? `Ã–dÃ¼l: +${rewardChips} Ã§ip` : "";
        return `${i+1}. ${def.desc}\n   Durum: ${status}\n   ${rewardText}`;
      });

      return msg.reply(
`ğŸ“œ *GÃ¼nlÃ¼k GÃ¶revler* (Her oyuncu iÃ§in her gÃ¼n rastgele seÃ§ilir)

${lines.join("\n\n")}`
      );
    }

    /* ---------- UNVAN SÄ°STEMÄ° ---------- */
    if (base === ".unvan" || base === ".unvanlar" || base === ".title" || base === ".titles") {
      if (!(await requireJoined(msg, player))) return;
      ensureTitles(player);
      await checkAndUnlockTitles(msg, player);
      const sub = (args[1] || "").toLowerCase();

      const owned = getOwnedTitleObjects(player);
      const activeName = getActiveTitleName(player);

      // admin Ã¶zel unvan verme: .unvan admin
      if (sub === "admin") {
        if (!isAdmin) {
          return msg.reply("ğŸš« Bu unvan sadece yÃ¶neticiler iÃ§indir.");
        }
        const adminDef = TITLE_DEFS.find(t => t.key === "admin_lord");
        if (!player.titles.owned.includes("admin_lord")) {
          player.titles.owned.push("admin_lord");
        }
        player.titles.activeKey = "admin_lord";
        await saveDB();
        return msg.reply(`ğŸ‘‘ Admin unvanÄ±n aktif edildi: ${adminDef?.name || "Sunucu Lordu"}`);
      }

      if (!sub) {
        if (!owned.length) {
          return msg.reply(
`ğŸ– *UnvanlarÄ±n*
HenÃ¼z hiÃ§ unvanÄ±n yok.
Oyun oynadÄ±kÃ§a sistem otomatik olarak sana unvan verecek.

Ã–rnek:
â€¢ Oyuna katÄ±ldÄ±ÄŸÄ±nda: ğŸ†• Yeni MaceracÄ±
â€¢ Zengin olduÄŸunda: ğŸ’° Zengin Oyuncu
â€¢ Hunt / Kutu / Pet yaptÄ±kÃ§a farklÄ± unvanlar...`
          );
        }
        const list = owned.map((t, i) =>
          `${i+1}. ${t.name} â€” ${t.desc}${t.name === activeName ? " (aktif)" : ""}`
        ).join("\n");
        const adminHint = isAdmin
          ? `\n\nğŸ‘‘ Admin isen Ã¶zel unvan iÃ§in:\n.unvan admin`
          : "";
        return msg.reply(
`ğŸ– *UnvanlarÄ±n*
Aktif: ${activeName || "Yok"}

${list}

Aktif unvanÄ± deÄŸiÅŸtirmek iÃ§in:
.unvan set <numara>${adminHint}`
        );
      }

      if (sub === "set" || sub === "sec" || sub === "seÃ§") {
        const sel = args[2];
        if (!sel) {
          return msg.reply("KullanÄ±m: `.unvan set <numara>`\nÃ–nce liste gÃ¶rmek iÃ§in: `.unvan`");
        }
        const idx = parseInt(sel, 10);
        if (!Number.isFinite(idx) || idx < 1 || idx > owned.length) {
          return msg.reply("âš ï¸ GeÃ§erli bir unvan numarasÄ± gir.\nListe gÃ¶rmek iÃ§in: `.unvan`");
        }
        const chosen = owned[idx - 1];
        player.titles.activeKey = chosen.key;
        await saveDB();
        return msg.reply(`ğŸ– Aktif unvanÄ±n artÄ±k: ${chosen.name}`);
      }

      return msg.reply("KullanÄ±m: `.unvan` (liste) | `.unvan set <numara>` (aktif et) | (admin iÃ§in) `.unvan admin`");
    }

    // .allpman
    if (base === ".allpman" || (base === ".bj" && (args[1]||"").toLowerCase() === "allpman")) {
      if (!isAdmin) return msg.reply("ğŸš« Bu komut iÃ§in yetkin yok.");
      Object.values(db.data.players).forEach(p => { p.stack += 5000; });
      await saveDB();
      return msg.reply("ğŸ’¸ TÃ¼m oyunculara +5000 Ã§ip eklendi.");
    }

    // .alpman
    if (base === ".alpman") {
      if (!isAdmin) return msg.reply("ğŸš« Bu komut iÃ§in yetkin yok.");
      player.stack += 15000;
      await saveDB();
      await checkAndUnlockTitles(msg, player);
      return msg.reply(`âœ… Kendine +15000 Ã§ip eklendi.\nğŸ¦ *Bakiye:* ${player.stack}`);
    }

    /* --- YENÄ°: .max (admin) --- */
    if (base === ".max") {
      if (!isAdmin) return msg.reply("ğŸš« Bu komut iÃ§in yetkin yok.");
      const ADD_AMOUNT = 999_999_999_999;
      player.stack += ADD_AMOUNT;
      await saveDB();
      await checkAndUnlockTitles(msg, player);
      return msg.reply(`âœ… +${ADD_AMOUNT} Ã§ip eklendi.\nğŸ¦ *Bakiye:* ${player.stack}`);
    }

    // .listedenat
    if (base === ".listedenat") {
      if (!isAdmin) return msg.reply("ğŸš« Bu komut iÃ§in yetkin yok.");
      const targets = await extractMentionedIds(msg);
      if (!targets.length) return msg.reply("âš ï¸ Listeden atmak iÃ§in @kiÅŸi belirt.");
      let count = 0;
      for (const tid of targets) {
        const tp = getPlayer(tid, db.data.players[tid]?.name || tid);
        if (tp.joined) { tp.joined = false; count++; }
      }
      await saveDB();
      return msg.reply(`ğŸ—‘ï¸ Skor listesinden Ã§Ä±karÄ±ldÄ±: ${count} kiÅŸi.`);
    }

    /* ==================== .admin bloÄŸu ==================== */
    if (base === ".admin") {
      const sub = (args[1] || "").toLowerCase();
      if (sub === "addme") {
        const pin = (args[2] || "").trim();
        if (!pin || pin !== ADMIN_PIN) return msg.reply("ğŸ” PIN hatalÄ±.");
        const fileAdmins = readAdmins();
        const s2 = await resolveSender(msg);
        if (s2.phoneId) {
          if (!fileAdmins.phones.includes(s2.phoneId)) fileAdmins.phones.push(s2.phoneId);
          writeAdmins(fileAdmins);
          return msg.reply(`âœ… Admin eklendi (telefon): ${s2.phoneId}`);
        } else if (s2.lid) {
          if (!fileAdmins.lids.includes(s2.lid)) fileAdmins.lids.push(s2.lid);
          writeAdmins(fileAdmins);
          return msg.reply(`âœ… Admin eklendi (LID): ${s2.lid}`);
        } else {
          return msg.reply("âš ï¸ Kimlik Ã§Ã¶zÃ¼mlenemedi.");
        }
      }
      if (sub === "delme") {
        const pin = (args[2] || "").trim();
        if (!pin || pin !== ADMIN_PIN) return msg.reply("ğŸ” PIN hatalÄ±.");
        const fileAdmins = readAdmins();
        let changed = false;
        const s2 = await resolveSender(msg);
        if (s2.phoneId) {
          const before = fileAdmins.phones.length;
          fileAdmins.phones = fileAdmins.phones.filter(p => p !== s2.phoneId);
          changed = changed || before !== fileAdmins.phones.length;
        }
        if (s2.lid) {
          const beforeL = fileAdmins.lids.length;
          fileAdmins.lids = fileAdmins.lids.filter(l => l !== s2.lid);
          changed = changed || beforeL !== fileAdmins.lids.length;
        }
        writeAdmins(fileAdmins);
        return msg.reply(changed ? "ğŸ—‘ï¸ Admin kaydÄ±n silindi." : "â„¹ï¸ KayÄ±t bulunamadÄ±.");
      }
      if (sub === "list") {
        const fileAdmins = readAdmins();
        return msg.reply(
          `ğŸ‘‘ Admin listesi\n` +
          `ENV phones: ${ADMIN_PHONES.join(", ") || "-"}\n` +
          `FILE phones: ${(fileAdmins.phones || []).join(", ") || "-"}\n` +
          `FILE lids: ${(fileAdmins.lids || []).join(", ") || "-"}`
        );
      }
      return msg.reply("KullanÄ±m: `.admin addme <PIN>` | `.admin delme <PIN>` | `.admin list`");
    }

    /* ==================== Blackjack BaÅŸlatma & YardÄ±m ==================== */
    if (base === ".bj" && args.length === 1) {
      return msg.reply(buildHelpText(isAdmin));
    }

    /* ==================== BJ akÄ±ÅŸÄ± ==================== */
    if (base === ".bj") {
      const sub = (args[1] || "").toLowerCase();

      if (sub === "bet") {
        if (!(await requireJoined(msg, player))) return;
        const bet = parseInt(args[2], 10);
        if (!Number.isFinite(bet) || bet < MIN_BET) return msg.reply(`âš ï¸ Minimum bahis ${MIN_BET} Ã§ip.`);
        if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");
        if (player.stack < bet) return msg.reply("ğŸš« Yetersiz bakiye!");

        const playerHand = [drawCard(), drawCard()];
        const dealerHand = [drawCard(), drawCard()];
        games[keyGame] = { bet, playerHand, dealerHand, canDouble: true, surrendered: false };
        const val = getHandValue(playerHand);

        return msg.reply(
`ğŸ´ *BLACKJACK* ğŸ´

âš¡ *Hareket:* ğŸƒ Yeni Oyun BaÅŸladÄ±

ğŸƒ *DaÄŸÄ±tÄ±cÄ±:* ${dealerHand[0].value}${suitDot(dealerHand[0].suit)} â“
ğŸ“Š *DeÄŸer:* ?

ğŸ‘¤ *.:* ${handToDotString(playerHand)}
ğŸ“Š *DeÄŸer:* ${valueText(val)}

ğŸ’µ *Bahis:* ${bet} ğŸ’°
ğŸ¦ *Bakiye:* ${player.stack} ğŸ’°

â¡ï¸ Komutlar: .hit | .stand | .db | .sur`
        );
      }

      const maybeBet = parseInt(args[1], 10);
      if (Number.isFinite(maybeBet)) {
        if (!(await requireJoined(msg, player))) return;
        if (maybeBet < MIN_BET) return msg.reply(`âš ï¸ Minimum bahis ${MIN_BET} Ã§ip.`);
        if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");
        if (player.stack < maybeBet) return msg.reply("ğŸš« Yetersiz bakiye!");

        const playerHand = [drawCard(), drawCard()];
        const dealerHand = [drawCard(), drawCard()];
        games[keyGame] = { bet: maybeBet, playerHand, dealerHand, canDouble: true, surrendered: false };
        const val = getHandValue(playerHand);

        return msg.reply(
`ğŸ´ *BLACKJACK* ğŸ´

âš¡ *Hareket:* ğŸƒ Yeni Oyun BaÅŸladÄ±

ğŸƒ *DaÄŸÄ±tÄ±cÄ±:* ${dealerHand[0].value}${suitDot(dealerHand[0].suit)} â“
ğŸ“Š *DeÄŸer:* ?

ğŸ‘¤ *.:* ${handToDotString(playerHand)}
ğŸ“Š *DeÄŸer:* ${valueText(val)}

ğŸ’µ *Bahis:* ${maybeBet} ğŸ’°
ğŸ¦ *Bakiye:* ${player.stack} ğŸ’°

â¡ï¸ Komutlar: .hit | .stand | .db | .sur`
        );
      }

      // .bj admin aliasâ€™larÄ±
      if (["admin","admin?","whoami","send","kilit","unlock","kick","skorreset","bakiyereset"].includes(sub)) {
        if (!isAdmin) return msg.reply("ğŸš« Bu komut iÃ§in yetkin yok.");

        if (sub === "admin" || sub === "admin?") return msg.reply(`ğŸ‘‘ Admin tanÄ±ndÄ±.`);
        if (sub === "whoami") return msg.reply(`ğŸ§ª Ä°sim: ${player.name || "-"} | joined=${player.joined} | Anahtar: ${makeGameKey(msg, s)}`);

        if (sub === "send") {
          await adminSendFunds(msg, player, args.slice(2), isAdmin);
          return;
        }

        if (sub === "kilit") {
          const targets = await extractMentionedIds(msg);
          if (!targets.length) return msg.reply("âš ï¸ @kiÅŸi belirt.");
          targets.forEach(tid => { const tp = getPlayer(tid, db.data.players[tid]?.name || tid); tp.locked = true; });
          await saveDB();
          return msg.reply("ğŸ”’ Belirtilen oyuncular kilitlendi.");
        }

        if (sub === "unlock") {
          const targets = await extractMentionedIds(msg);
          if (!targets.length) return msg.reply("âš ï¸ @kiÅŸi belirt.");
          targets.forEach(tid => { const tp = getPlayer(tid, db.data.players[tid]?.name || tid); tp.locked = false; });
          await saveDB();
          return msg.reply("ğŸ”“ Kilitler aÃ§Ä±ldÄ±.");
        }

        if (sub === "kick") {
          const targets = await extractMentionedIds(msg);
          if (!targets.length) return msg.reply("âš ï¸ @kiÅŸi belirt.");
          targets.forEach(tid => { delete db.data.players[tid]; });
          await saveDB();
          return msg.reply("ğŸ—‘ï¸ Oyuncu(lar) sistemden silindi.");
        }

        if (sub === "skorreset") {
          db.data.players = {};
          await saveDB();
          return msg.reply("â™»ï¸ TÃ¼m skor ve veriler sÄ±fÄ±rlandÄ±.");
        }

        if (sub === "bakiyereset") {
          const tgt = await resolveSingleTarget(msg);
          if (!tgt.ok) return msg.reply(tgt.message);
          const tid = tgt.id;
          const tp = getPlayer(tid, db.data.players[tid]?.name || tid);
          tp.stack = 0;
          await saveDB();
          return msg.reply(`ğŸ§° ${tp.name || tid} iÃ§in bakiye *0* yapÄ±ldÄ±.`);
        }
      }
    }

    /* ==================== Oyun AksiyonlarÄ± (BJ) ==================== */
    if (base === ".hit") {
      const game = games[makeGameKey(msg, s)];
      if (!game) return;
      if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");

      const anim = animations[Math.floor(Math.random() * animations.length)];
      await msg.reply(`${anim} Kart Ã§ekiliyor...`);
      await new Promise(res => setTimeout(res, 900));

      game.playerHand.push(drawCard());
      game.canDouble = false;
      const val = getHandValue(game.playerHand);

      if (val > 21) {
        delete games[makeGameKey(msg, s)];
        player.stack -= game.bet;
        ensureStats(player);
        player.stats.bjGames += 1;
        player.stats.bjLosses += 1;
        applyQuestProgress(player, "bjPlay", 1);
        await saveDB();
        await checkAndUnlockTitles(msg, player);
        return msg.reply(
`ğŸ´ *BLACKJACK* ğŸ´

âš¡ *Hareket:* ğŸ’¥ Oyun Bitti

ğŸƒ *DaÄŸÄ±tÄ±cÄ±:* ${handToDotString(game.dealerHand)}
ğŸ“Š *DeÄŸer:* ${getHandValue(game.dealerHand)}

ğŸ‘¤ *.:* ${handToDotString(game.playerHand)}
ğŸ“Š *DeÄŸer:* BUST! ğŸ’¥

ğŸ’µ *Bahis:* ${game.bet} ğŸ’°
ğŸ¦ *Bakiye:* ${player.stack} ğŸ’°

âŒ Kaybettin -${game.bet}`
        );
      }

      return msg.reply(
`ğŸ´ *BLACKJACK* ğŸ´

âš¡ *Hareket:* Kart Ã‡ekildi

ğŸƒ *DaÄŸÄ±tÄ±cÄ±:* ${game.dealerHand[0].value}${suitDot(game.dealerHand[0].suit)} â“
ğŸ“Š *DeÄŸer:* ?

ğŸ‘¤ *.:* ${handToDotString(game.playerHand)}
ğŸ“Š *DeÄŸer:* ${valueText(val)}

ğŸ’µ *Bahis:* ${game.bet} ğŸ’°
ğŸ¦ *Bakiye:* ${player.stack} ğŸ’°`
      );
    }

    if (base === ".db") {
      const game = games[makeGameKey(msg, s)];
      if (!game) return;
      if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");
      if (!game.canDouble) return msg.reply("âš ï¸ Double sadece ilk iki karttan sonra ve hiÃ§ hit yapmadan mÃ¼mkÃ¼ndÃ¼r.");
      if (player.stack < game.bet) return msg.reply("ğŸš« Yetersiz bakiye (double iÃ§in aynÄ± miktar gerekir).");

      player.stack -= game.bet;
      game.bet *= 2;
      game.playerHand.push(drawCard());
      game.canDouble = false;

      let dealerVal = getHandValue(game.dealerHand);
      while (dealerVal < 17) {
        game.dealerHand.push(drawCard());
        dealerVal = getHandValue(game.dealerHand);
      }
      const playerVal = getHandValue(game.playerHand);

      let outcome = "push";
      let result;
      if (playerVal > 21) {
        outcome = "lose";
        result = `ğŸ˜ Kaybettin -${game.bet}`;
      } else if (dealerVal > 21 || playerVal > dealerVal) {
        outcome = "win";
        player.stack += game.bet * 2;
        result = `ğŸ† KazandÄ±n! +${game.bet}`;
      } else if (playerVal < dealerVal) {
        outcome = "lose";
        result = `ğŸ˜ Kaybettin -${game.bet}`;
      } else {
        outcome = "push";
        player.stack += game.bet;
        result = `ğŸ¤ Berabere!`;
      }

      ensureStats(player);
      player.stats.bjGames += 1;
      if (outcome === "win") player.stats.bjWins += 1;
      if (outcome === "lose") player.stats.bjLosses += 1;
      applyQuestProgress(player, "bjPlay", 1);

      await saveDB();
      delete games[makeGameKey(msg, s)];
      await checkAndUnlockTitles(msg, player);

      return msg.reply(
`ğŸ´ *BLACKJACK* ğŸ´

âš¡ *Hareket:* ğŸ’¥ Oyun Bitti

ğŸƒ *DaÄŸÄ±tÄ±cÄ±:* ${handToDotString(game.dealerHand)}
ğŸ“Š *DeÄŸer:* ${dealerVal}

ğŸ‘¤ *.:* ${handToDotString(game.playerHand)}
ğŸ“Š *DeÄŸer:* ${valueText(playerVal)}

ğŸ’µ *Bahis:* ${game.bet} ğŸ’°
ğŸ¦ *Bakiye:* ${player.stack} ğŸ’°

${result}`
      );
    }

    if (base === ".sur") {
      const game = games[makeGameKey(msg, s)];
      if (!game) return;
      if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");
      const loss = Math.ceil(game.bet / 2);
      player.stack -= loss;
      ensureStats(player);
      player.stats.bjGames += 1;
      player.stats.bjLosses += 1;
      applyQuestProgress(player, "bjPlay", 1);
      await saveDB();
      delete games[makeGameKey(msg, s)];
      await checkAndUnlockTitles(msg, player);

      return msg.reply(
`ğŸ´ *BLACKJACK* ğŸ´

âš¡ *Hareket:* ğŸ³ï¸ Oyun Bitti

ğŸƒ *DaÄŸÄ±tÄ±cÄ±:* â€”
ğŸ“Š *DeÄŸer:* â€”

ğŸ‘¤ *.:* â€”
ğŸ“Š *DeÄŸer:* â€”

ğŸ’µ *Bahis:* ${game.bet} ğŸ’°
ğŸ¦ *Bakiye:* ${player.stack} ğŸ’°

ğŸ’¸ *KayÄ±p:* -${loss}`
      );
    }

    if (base === ".stand") {
      const game = games[makeGameKey(msg, s)];
      if (!game) return;
      if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");

      let dealerVal = getHandValue(game.dealerHand);
      while (dealerVal < 17) {
        game.dealerHand.push(drawCard());
        dealerVal = getHandValue(game.dealerHand);
      }
      const playerVal = getHandValue(game.playerHand);
      let result = "";
      let outcome = "push";
      if (playerVal > 21) {
        player.stack -= game.bet;
        outcome = "lose";
        result = `ğŸ˜ Kaybettin -${game.bet}`;
      } else if (dealerVal > 21 || playerVal > dealerVal) {
        player.stack += game.bet;
        outcome = "win";
        result = `ğŸ† KazandÄ±n! +${game.bet}`;
      } else if (playerVal < dealerVal) {
        player.stack -= game.bet;
        outcome = "lose";
        result = `ğŸ˜ Kaybettin -${game.bet}`;
      } else {
        outcome = "push";
        result = `ğŸ¤ Berabere!`;
      }

      ensureStats(player);
      player.stats.bjGames += 1;
      if (outcome === "win") player.stats.bjWins += 1;
      if (outcome === "lose") player.stats.bjLosses += 1;
      applyQuestProgress(player, "bjPlay", 1);

      await saveDB();
      delete games[makeGameKey(msg, s)];
      await checkAndUnlockTitles(msg, player);

      return msg.reply(
`ğŸ´ *BLACKJACK* ğŸ´

âš¡ *Hareket:* ğŸ’¥ Oyun Bitti

ğŸƒ *DaÄŸÄ±tÄ±cÄ±:* ${handToDotString(game.dealerHand)}
ğŸ“Š *DeÄŸer:* ${dealerVal}

ğŸ‘¤ *.:* ${handToDotString(game.playerHand)}
ğŸ“Š *DeÄŸer:* ${valueText(playerVal)}

ğŸ’µ *Bahis:* ${game.bet} ğŸ’°
ğŸ¦ *Bakiye:* ${player.stack} ğŸ’°

${result}`
      );
    }

    /* ==================== Admin KÄ±sayol Para GÃ¶nder (.send) ==================== */
    if (base === ".send") {
      await adminSendFunds(msg, player, args.slice(1), isAdmin);
      return;
    }

    /* ==================== HUNT (.hunt) ==================== */
    if (base === ".hunt") {
      if (!(await requireJoined(msg, player))) return;
      if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");

      ensureStats(player);
      ensureInventory(player);
      ensurePet(player);

      const petAtk = player.pet?.atk || 0;
      const petLuck = player.pet?.luck || 0;

      const baseMin = 20 + petAtk * 2;
      const baseMax = 80 + petAtk * 3;
      const baseGain = randInt(baseMin, baseMax);

      let buffMult = 1;
      let buffLine = "";
      if (isEventBuffActive()) {
        buffMult = 1.5;
        buffLine = "\nâš¡ Etkinlik buff'Ä± aktif: Hunt kazancÄ± arttÄ±!";
      }

      const gain = Math.round(baseGain * buffMult);

      const baseDropChance = 0.3;
      const bonusDrop = petLuck * 0.02;
      const buffDropBonus = isEventBuffActive() ? 0.05 : 0;
      const boxDrop = Math.random() < (baseDropChance + bonusDrop + buffDropBonus);

      player.stack += gain;
      player.stats.huntCount += 1;
      player.stats.huntProfit += gain;

      if (boxDrop) {
        player.inv.boxes += 1;
      }

      applyQuestProgress(player, "huntTimes", 1);

      await saveDB();
      await checkAndUnlockTitles(msg, player);

      let extra = boxDrop
        ? `\nğŸ Av sÄ±rasÄ±nda *1 kutu* buldun! (Toplam kutu: ${player.inv.boxes})`
        : "";

      let petInfo = "";
      if (player.pet) {
        petInfo =
`\n\nğŸ¾ Pet BufflarÄ±:
ATK: ${petAtk} â†’ Hunt kazancÄ±n biraz arttÄ±
LUCK: ${petLuck} â†’ Kutu dÃ¼ÅŸme ÅŸansÄ±n yÃ¼kseldi`;
      }

      return msg.reply(
`ğŸ¹ *HUNT SONUCU* ğŸ¹

KazanÃ§: +${gain} Ã§ip${extra}
ğŸ¦ Bakiye: ${player.stack}${petInfo}${buffLine}`
      );
    }

    /* ==================== KUTU (.kutu / .box) ==================== */
    if (base === ".kutu" || base === ".box") {
      if (!(await requireJoined(msg, player))) return;
      if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");

      ensureStats(player);
      ensureInventory(player);
      ensurePet(player);

      if (player.inv.boxes <= 0) {
        return msg.reply("ğŸ HiÃ§ kutun yok. .hunt yaparak kutu bulabilirsin.");
      }

      player.inv.boxes -= 1;

      const roll = Math.random();
      let reward = 0;
      let flavor = "";

      if (roll < 0.05) {
        reward = randInt(800, 1500);
        flavor = "ğŸ’ *EFSANE Ã–DÃœL!*";
      } else if (roll < 0.25) {
        reward = randInt(300, 600);
        flavor = "âœ¨ GÃ¼zel bir Ã¶dÃ¼l buldun.";
      } else {
        reward = randInt(50, 200);
        flavor = "ğŸ KÃ¼Ã§Ã¼k bir Ã¶dÃ¼l Ã§Ä±ktÄ±.";
      }

      const petLuck = player.pet?.luck || 0;
      let petBonus = 0;
      if (petLuck > 0) {
        petBonus = randInt(0, petLuck * 20);
        reward += petBonus;
      }

      let buffBonus = 0;
      let buffLine = "";
      if (isEventBuffActive()) {
        const before = reward;
        reward = Math.round(reward * 1.4);
        buffBonus = reward - before;
        buffLine = `\nâš¡ Etkinlik buff'Ä± bonusu: +${buffBonus} Ã§ip`;
      }

      player.stack += reward;
      player.stats.boxesOpened += 1;
      applyQuestProgress(player, "boxOpen", 1);

      await saveDB();
      await checkAndUnlockTitles(msg, player);

      let petLine = "";
      if (petBonus > 0) {
        petLine = `\nğŸ¾ Pet bonusu: +${petBonus} Ã§ip (LUCK etkisi)`;
      }

      return msg.reply(
`ğŸ *KUTU AÃ‡ILDI* ğŸ

${flavor}
KazanÃ§: +${reward} Ã§ip${petLine}${buffLine}
Kalan kutu: ${player.inv.boxes}
ğŸ¦ Bakiye: ${player.stack}`
      );
    }

    /* ==================== Slot & Jackpot ==================== */
    if (base === ".slot") {
      const bet = parseInt(args[1], 10);
      if (!Number.isFinite(bet) || bet < MIN_BET) return msg.reply(`âš ï¸ Minimum bahis ${MIN_BET}`);
      if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");
      if (player.stack < bet) return msg.reply("ğŸš« Yetersiz bakiye!");

      const grid = spinSlot();
      const { totalWin, lines } = checkSlotWin(grid, bet);
      const net = totalWin - bet;
      player.stack += net;

      ensureStats(player);
      player.stats.slotGames += 1;
      player.stats.slotNetWin += net;
      applyQuestProgress(player, "slotPlay", 1);

      await saveDB();
      await checkAndUnlockTitles(msg, player);

      const gridText = grid.map(r => r.join(" ")).join("\n");
      const resultText = net > 0 ? `ğŸ† *KazandÄ±n!* +${net}` : `ğŸ˜ *Kaybettin* -${bet}`;
      const lineText = lines.length ? lines.join("\n") : "ğŸ”¸ HiÃ§ kazanÃ§ yok";
      const jpText = `ğŸ’° Jackpot: ${jackpot}`;

      return msg.reply(
`ğŸ° *SLOT SONUCU* ğŸ°

${gridText}

${lineText}
${resultText}
${jpText}
ğŸ’³ Bakiye: ${player.stack}`
      );
    }

    if (base === ".jackpot") {
      return msg.reply(`ğŸ’° *GÃ¼ncel Jackpot:* ${jackpot} Ã§ip ğŸ’`);
    }

    /* ==================== RULET ==================== */
    if (base === ".rulet" && args.length === 1) {
      return msg.reply(ROULET_HELP);
    }

    if (base === ".rulet") {
      if (!(await requireJoined(msg, player))) return;

      const bet = parseInt(args[1], 10);
      if (!Number.isFinite(bet) || bet < MIN_BET) {
        return msg.reply(
`ğŸ¡ *RULET YARDIMI*
KullanÄ±m: .rulet <miktar> <seÃ§im>

Ã–rnekler:
â€¢ .rulet 100 kÄ±rmÄ±zÄ±
â€¢ .rulet 200 tek
â€¢ .rulet 150 1-12
â€¢ .rulet 50 17
â€¢ .rulet 100 0

Ã–deme:
â€¢ Renk/Tek-Ã‡ift/1-18/19-36 â†’ 1:1
â€¢ 1-12 / 13-24 / 25-36 â†’ 2:1
â€¢ Tek sayÄ± (0-36) â†’ 35:1`
        );
      }
      if (player.locked) return msg.reply("ğŸ”’ HesabÄ±n kilitli.");
      if (player.stack < bet) return msg.reply("ğŸš« Yetersiz bakiye!");

      const pick = parseRoulettePick(args.slice(2));
      if (!pick.ok) return msg.reply(pick.message);

      const anims = ["ğŸ¡", "ğŸ¯", "ğŸŒ€", "âœ¨", "ğŸ¯", "ğŸ¡"];
      await msg.reply(`${anims[0]} Teker dÃ¶nÃ¼yor...`);
      await new Promise(r => setTimeout(r, 900));
      await msg.reply(`${anims[2]} HÄ±zlanÄ±yor...`);
      await new Promise(r => setTimeout(r, 700));

      const n = rouletteSpin();
      const col = rouletteColor(n);
      const won = pick.test(n);
      let delta;
      let info;

      if (won) {
        const profit = bet * pick.payout;
        delta = profit;
        info = pick.payout === 1
          ? `ğŸ† *KazandÄ±n!* +${profit}`
          : `ğŸ† *KazandÄ±n!* +${profit} (Ã¶deme ${pick.payout}:1)`;
      } else {
        delta = -bet;
        info = `ğŸ˜ *Kaybettin* -${bet}`;
      }

      player.stack += delta;

      ensureStats(player);
      player.stats.rouletteGames += 1;
      if (won) {
        player.stats.rouletteWins += 1;
        applyQuestProgress(player, "rouletteWin", 1);
      } else {
        player.stats.rouletteLosses += 1;
      }

      await saveDB();
      await checkAndUnlockTitles(msg, player);

      const numBadge = n === 0 ? "0 ğŸŸ¢" : `${n} ${col.dot}`;
      return msg.reply(
`ğŸ¡ *RULET SONUCU* ğŸ¡

ğŸ² *Top:* ${numBadge} (${col.name})
ğŸ¯ *SeÃ§im:* ${pick.title}
ğŸ’µ *Bahis:* ${bet}

${info}
ğŸ¦ *Bakiye:* ${player.stack}`
      );
    }

    /* ==================== GÃ¼nlÃ¼k Ã¶dÃ¼l (manuel komut) ==================== */
    if (base === ".gÃ¼nlÃ¼k" || base === ".gunluk" || base === ".daily") {
      if (!(await requireJoined(msg, player))) return;
      const key = localDateKey();
      if (player.lastDaily === key) return msg.reply("â³ GÃ¼nlÃ¼k Ã¶dÃ¼lÃ¼nÃ¼ zaten aldÄ±n.");
      player.lastDaily = key;
      player.stack += DAILY_REWARD;
      ensureStats(player);
      player.stats.dailyDays = (player.stats.dailyDays || 0) + 1;
      applyQuestProgress(player, "dailyClaim", 1);
      await saveDB();
      await checkAndUnlockTitles(msg, player);
      return msg.reply(`ğŸ *GÃ¼nlÃ¼k Ã¶dÃ¼l:* +${DAILY_REWARD}\nğŸ¦ Bakiye: ${player.stack}`);
    }

  } catch (err) {
    console.error("Mesaj iÅŸleme hatasÄ±:", err);
    try { await msg.reply("âš ï¸ Ä°Ã§ hata oluÅŸtu, lÃ¼tfen tekrar deneyin."); } catch {}
  }
}

/* ========== SADECE message_create DÄ°NLÄ°YORUZ ========== */
client.on("message_create", (msg) => {
  // if (msg.fromMe) return; // kendi mesajlarÄ±nÄ± hariÃ§ tutmak istersen aÃ§
  handleMessageSafe(msg);
});
// client.on("message", handleMessageSafe); // âŒ KULLANMA â€” Ã§ift tetik yapar

// SÃ¼reklilik
process.on("uncaughtException", e => console.error("uncaughtException:", e));
process.on("unhandledRejection", e => console.error("unhandledRejection:", e));

client.initialize();

/* --- Admin para gÃ¶nderme â€” (DEDUPE EKLENDÄ°) --- */
async function adminSendFunds(msg, senderPlayer, rawArgs, isAdmin) {
  if (!isAdmin) {
    await msg.reply("ğŸš« Bu komut iÃ§in yetkin yok.");
    return;
  }
  const mid = msg?.id?._serialized || msg?.id?.id || `${msg.timestamp}:${msg.from}`;
  const txKey = `tx:${mid}`;
  if (DONE_TX.has(txKey)) return;
  DONE_TX.add(txKey);

  const amount = parseInt(rawArgs.find(a => /^\d+$/.test(a)), 10);
  if (!Number.isFinite(amount) || amount <= 0) {
    await msg.reply("âš ï¸ GeÃ§erli bir miktar gir: `.send 500 @kiÅŸi`");
    setTimeout(() => DONE_TX.delete(txKey), 60_000);
    return;
  }

  const tgt = await resolveSingleTarget(msg);
  if (!tgt.ok) {
    await msg.reply(tgt.message);
    setTimeout(() => DONE_TX.delete(txKey), 60_000);
    return;
  }
  const tid = tgt.id;

  if (senderPlayer.stack < amount) {
    await msg.reply(`ğŸš« Yetersiz bakiye. Gerekli: ${amount}, Senin: ${senderPlayer.stack}`);
    setTimeout(() => DONE_TX.delete(txKey), 60_000);
    return;
  }

  const tp = getPlayer(tid, db.data.players[tid]?.name || tid);
  senderPlayer.stack -= amount;
  tp.stack += amount;
  await saveDB();

  await msg.reply(
    `âœ… GÃ¶nderildi: ${tp.name || tid} â†’ +${amount}\n` +
    `ğŸ’³ Kalan bakiyen: ${senderPlayer.stack}`
  );

  setTimeout(() => DONE_TX.delete(txKey), 60_000);
}
